(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**This class is automatically generated by LayaAirIDE, please do not make any modifications. */
const GameUI_1 = require("./script/GameUI");
/*
* 游戏初始化配置;
*/
class GameConfig {
    constructor() { }
    static init() {
        var reg = Laya.ClassUtils.regClass;
        reg("script/GameUI.ts", GameUI_1.default);
    }
}
exports.default = GameConfig;
GameConfig.width = 750;
GameConfig.height = 1334;
GameConfig.scaleMode = "showall";
GameConfig.screenMode = "none";
GameConfig.alignV = "top";
GameConfig.alignH = "left";
GameConfig.startScene = "test/TestScene.scene";
GameConfig.sceneRoot = "";
GameConfig.debug = false;
GameConfig.stat = false;
GameConfig.physicsDebug = false;
GameConfig.exportSceneToJson = true;
GameConfig.init();

},{"./script/GameUI":44}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameConfig_1 = require("./GameConfig");
const SceneManager_1 = require("./core/SceneManager");
const LoadingScene_1 = require("./script/scene/LoadingScene");
const GameScene_1 = require("./script/scene/GameScene");
const GameConfigData_1 = require("./script/common/GameConfigData");
const ResLoader_1 = require("./core/util/ResLoader");
const ProjectConfig_1 = require("./script/common/ProjectConfig");
class Main {
    constructor() {
        //根据IDE设置初始化引擎		
        let height;
        Laya.Browser.onMobile = window.isConchApp ? true : window.navigator.userAgent.indexOf("Mobile") > -1;
        if (Laya.Browser.onMobile) {
            height = Laya.Browser.clientHeight / Laya.Browser.clientWidth * GameConfig_1.default.width;
        }
        else {
            height = GameConfig_1.default.height;
        }
        if (window["Laya3D"])
            Laya3D.init(GameConfig_1.default.width, height);
        else
            Laya.init(GameConfig_1.default.width, height, Laya["WebGL"]);
        Laya["Physics"] && Laya["Physics"].enable();
        Laya["DebugPanel"] && Laya["DebugPanel"].enable();
        Laya.stage.scaleMode = GameConfig_1.default.scaleMode;
        Laya.stage.screenMode = GameConfig_1.default.screenMode;
        Laya.stage.alignV = Laya.Stage.ALIGN_CENTER;
        Laya.stage.alignH = Laya.Stage.ALIGN_MIDDLE;
        //兼容微信不支持加载scene后缀场景
        Laya.URL.exportSceneToJson = GameConfig_1.default.exportSceneToJson;
        //打开调试面板（通过IDE设置调试模式，或者url地址增加debug=true参数，均可打开调试面板）
        if (GameConfig_1.default.debug || Laya.Utils.getQueryString("debug") == "true")
            Laya.enableDebugPanel();
        if (GameConfig_1.default.physicsDebug && Laya["PhysicsDebugDraw"])
            Laya["PhysicsDebugDraw"].enable();
        if (GameConfig_1.default.stat)
            Laya.Stat.show();
        // 全局报错提示
        // Laya.alertGlobalError = true;
        // 设置ui后缀
        fgui.UIConfig.packageFileExtension = "bin";
        //激活资源版本控制，version.json由IDE发布功能自动生成，如果没有也不影响后续流程
        Laya.ResourceVersion.enable("version.json", Laya.Handler.create(this, this.onVersionLoaded), Laya.ResourceVersion.FILENAME_VERSION);
    }
    onVersionLoaded() {
        //激活大小图映射，加载小图的时候，如果发现小图在大图合集里面，则优先加载大图合集，而不是小图
        Laya.AtlasInfoManager.enable("fileconfig.json", Laya.Handler.create(this, this.onFileConfLoaded));
    }
    onFileConfLoaded() {
        ResLoader_1.default.load(["config.json"], this, this.onConfigLoaded);
    }
    onConfigLoaded() {
        //加载IDE指定的场景
        // GameConfig.startScene && Laya.Scene.open(GameConfig.startScene);
        ProjectConfig_1.ProjectConfig.Ins.init();
        if (ProjectConfig_1.ProjectConfig.Ins.cdnUrl) {
            Laya.URL.basePath = ProjectConfig_1.ProjectConfig.Ins.cdnUrl;
        }
        GameConfigData_1.default.Ins.init();
        SceneManager_1.default.setLoadScene(LoadingScene_1.default);
        SceneManager_1.default.open(GameScene_1.default);
    }
}
//激活启动类
new Main();

},{"./GameConfig":1,"./core/SceneManager":13,"./core/util/ResLoader":41,"./script/common/GameConfigData":48,"./script/common/ProjectConfig":49,"./script/scene/GameScene":83,"./script/scene/LoadingScene":84}],3:[function(require,module,exports){
"use strict";
/**
 * 组件
 */
Object.defineProperty(exports, "__esModule", { value: true });
const LogicScheduler_1 = require("./LogicScheduler");
const EventManager_1 = require("./EventManager");
class BaseComponent {
    constructor() {
        // 启用update()
        this.updateComp = false;
        // 启用lateUpdate()
        this.lateUpdateComp = false;
    }
    onLoad(...params) {
        this.onEnable();
    }
    onDestory() {
        this.onDisable();
        EventManager_1.default.offAll(this);
    }
    onEnable() {
        LogicScheduler_1.default.Ins.enableComp(this);
    }
    onDisable() {
        LogicScheduler_1.default.Ins.disableComp(this);
    }
    update(detal) {
    }
    lateUpdate(detal) {
    }
}
exports.default = BaseComponent;

},{"./EventManager":11,"./LogicScheduler":12}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BaseController {
    onLoad() {
    }
    onDestory() {
    }
}
exports.default = BaseController;

},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("./util/Logger");
const IdGenerater_1 = require("./util/IdGenerater");
const ActionManager_1 = require("./action/ActionManager");
const LogicScheduler_1 = require("./LogicScheduler");
const EntityTypeDefine_1 = require("./util/EntityTypeDefine");
class BaseEntity {
    constructor() {
        this._entityType = EntityTypeDefine_1.EntityType.BaseEntity;
        this._components = [];
        this._eventMap = new Map();
        this._uuid = IdGenerater_1.getNewUuid();
    }
    dependAssets() {
        return null;
    }
    ;
    on(type, context, callback, priority = 0) {
        if (!type || !callback || !context) {
            return;
        }
        if (!this._eventMap.has(type)) {
            this._eventMap.set(type, []);
        }
        let subEventList = this._eventMap.get(type);
        if (this.isExistListener(context, callback, subEventList)) {
            return;
        }
        let event = {
            type,
            context,
            priority,
            callback
        };
        if (priority > 0) {
            let isPush = true;
            for (let i = subEventList.length - 1; i >= 0; i--) {
                if (subEventList[i].priority > priority) {
                    subEventList.splice(i + 1, 0, event);
                    isPush = false;
                    break;
                }
            }
            if (isPush) {
                subEventList.splice(0, 0, event);
            }
        }
        else {
            subEventList.push(event);
        }
    }
    emit(type, ...params) {
        if (!type) {
            return;
        }
        let subEventList = this._eventMap.get(type);
        if (!subEventList) {
            return;
        }
        for (let i = subEventList.length - 1; i >= 0; i--) {
            let event = subEventList[i];
            let callback = event.callback;
            let context = event.context;
            callback.apply(context, params);
        }
    }
    isExistListener(context, callback, subEventList) {
        for (let i = 0; i < subEventList.length; i++) {
            if ((subEventList[i].context === context) && (subEventList[i].callback === callback)) {
                return true;
            }
        }
        return false;
    }
    off(type, context, callback) {
        if (!type || !callback) {
            return;
        }
        let subEventList = this._eventMap.get(type);
        if (!subEventList) {
            return;
        }
        for (let i = subEventList.length - 1; i >= 0; i--) {
            if ((subEventList[i].context === context) && (subEventList[i].callback === callback)) {
                subEventList.splice(i, 1);
                break;
            }
        }
        if (subEventList.length == 0) {
            delete this._eventMap[type];
        }
    }
    offAll(context) {
        this._eventMap.forEach((subEventList, type) => {
            for (let i = subEventList.length - 1; i >= 0; i--) {
                if ((subEventList[i].context === context)) {
                    subEventList.splice(i, 1);
                }
            }
            if (subEventList.length == 0) {
                delete this._eventMap[type];
            }
        });
    }
    get uuid() {
        return this._uuid;
    }
    get model() {
        return this._model;
    }
    addComponent(component, ...params) {
        let comp = this.getComponent(component);
        if (comp != null) {
            Logger_1.warn(`addComponent ${component.prototype.constructor.name} already exist`);
            return null;
        }
        else {
            let comp = new component();
            comp.entity = this;
            comp.onLoad.apply(comp, ...params);
            this._components.push(comp);
            return comp;
        }
    }
    getComponent(component) {
        for (let i = 0; i < this._components.length; ++i) {
            let comp = this._components[i];
            if (comp.constructor === component) {
                return comp;
            }
        }
        return null;
    }
    removeAllComponent() {
        for (let i = 0; i < this._components.length; ++i) {
            let comp = this._components[i];
            comp.onDestory();
        }
        this._components.length = 0;
    }
    removeComponent(component) {
        for (let i = 0; i < this._components.length; ++i) {
            let comp = this._components[i];
            if (comp.constructor === component) {
                comp.onDestory();
                this._components.splice(i, 1);
                ;
                return;
            }
        }
    }
    runAction(action) {
        ActionManager_1.default.addAction(action, this);
    }
    removeAllActions() {
        ActionManager_1.default.removeAllActionsFromTarget(this);
    }
    get entityType() {
        return this._entityType;
    }
    onDestory() {
        this._eventMap.clear();
        this._eventMap = null;
        this.removeAllComponent();
        LogicScheduler_1.default.clearAll(this);
        ActionManager_1.default.removeAllActionsFromTarget(this);
    }
}
exports.default = BaseEntity;

},{"./LogicScheduler":12,"./action/ActionManager":18,"./util/EntityTypeDefine":35,"./util/IdGenerater":38,"./util/Logger":39}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseScene_1 = require("./BaseScene");
const ResLoader_1 = require("./util/ResLoader");
class BaseLoadScene extends BaseScene_1.default {
    dependAssets() {
        let assets = [];
        return assets;
    }
    onLoad() {
    }
    loadUrls(urls, context = null, complete = null) {
        this._context = context;
        this._complete = complete;
        if (!urls || urls.length === 0) {
            this.onComplete();
            return;
        }
        ResLoader_1.default.load(urls, this, this.onComplete, this.onProgress);
    }
    onComplete() {
        if (this._context && this._complete) {
            this._complete.apply(this._context);
        }
    }
    show() {
        this._scene.visible = true;
    }
    hide() {
        this._scene.visible = false;
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = BaseLoadScene;

},{"./BaseScene":8,"./util/ResLoader":41}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BaseModel {
    constructor(guid) {
        this._guid = guid;
        this._localPosition = new Laya.Vector3(0, 0, 0);
        this._localRotationEuler = new Laya.Vector3(0, 0, 0);
        this._localScale = new Laya.Vector3(0, 0, 0);
    }
    get guid() {
        return this._guid;
    }
    get localPosition() {
        return this._localPosition;
    }
    get localRotationEuler() {
        return this._localRotationEuler;
    }
    get localScale() {
        return this._localScale;
    }
    setPosition(x, y, z) {
        if (x != undefined && y != undefined && y != undefined) {
            this._localPosition.setValue(x, y, z);
        }
    }
    setRotation(x, y, z) {
        if (x != undefined && y != undefined && y != undefined) {
            this._localRotationEuler.setValue(x, y, z);
        }
    }
    setScale(x, y, z) {
        if (x != undefined && y != undefined && y != undefined) {
            this._localScale.setValue(x, y, z);
        }
    }
    onDestory() {
        this._localPosition = null;
        this._localRotationEuler = null;
        this._localScale = null;
    }
}
exports.default = BaseModel;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BaseScene {
    constructor() {
    }
    onLoad() {
    }
    addChild(node) {
        this._scene.addChild(node);
    }
    get scene() {
        return this._scene;
    }
    onDestory() {
        this._scene.removeSelf();
        this._scene.destroy(true);
        Laya.Render.context.clear();
    }
}
exports.default = BaseScene;

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseComponent_1 = require("./BaseComponent");
class BaseView extends BaseComponent_1.default {
    constructor() {
        super();
    }
    onLoad(...params) {
        super.onLoad();
    }
    onDestory() {
        this.view.dispose();
        this.view = null;
    }
    show() {
        if (this.view) {
            this.view.visible = true;
        }
    }
    hide() {
        if (this.view) {
            this.view.visible = false;
        }
    }
    removeSelf() {
        if (this.view) {
            this.view.removeFromParent();
            this.onDestory();
        }
    }
}
exports.default = BaseView;

},{"./BaseComponent":3}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BindEntityScript extends Laya.Script3D {
    constructor() {
        super();
    }
    setEntity(v) {
        this._entity = v;
    }
    get entity() {
        return this._entity;
    }
    onDestroy() {
        super.onDestroy();
        this._entity = null;
    }
}
exports.default = BindEntityScript;

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class EventManager {
    constructor() {
        this._eventMap = new Map();
    }
    static get Ins() {
        if (!EventManager._eventManager) {
            EventManager._eventManager = new EventManager();
        }
        return EventManager._eventManager;
    }
    clear() {
        this._eventMap.clear();
        this._eventMap = null;
    }
    static on(type, context, callback, priority = 0) {
        if (!type || !callback || !context) {
            return;
        }
        if (!EventManager.Ins._eventMap.has(type)) {
            EventManager.Ins._eventMap[type] = [];
        }
        let subEventList = EventManager.Ins._eventMap[type];
        if (EventManager.Ins.isExistListener(context, callback, subEventList)) {
            return;
        }
        let event = {
            type,
            context,
            priority,
            callback
        };
        if (priority > 0) {
            let isPush = true;
            for (let i = subEventList.length - 1; i >= 0; i--) {
                if (subEventList[i].priority > priority) {
                    subEventList.splice(i + 1, 0, event);
                    isPush = false;
                    break;
                }
            }
            if (isPush) {
                subEventList.splice(0, 0, event);
            }
        }
        else {
            subEventList.push(event);
        }
    }
    isExistListener(context, callback, subEventList) {
        for (let i = 0; i < subEventList.length; i++) {
            if ((subEventList[i].context === context) && (subEventList[i].callback === callback)) {
                return true;
            }
        }
        return false;
    }
    static emit(type, ...params) {
        if (!type) {
            return;
        }
        let subEventList = EventManager.Ins._eventMap[type];
        if (!subEventList) {
            return;
        }
        for (let i = subEventList.length - 1; i >= 0; i--) {
            let event = subEventList[i];
            let callback = event.callback;
            let context = event.context;
            callback.apply(context, params);
        }
    }
    static off(type, context, callback) {
        if (!type || !callback) {
            return;
        }
        let subEventList = EventManager.Ins._eventMap[type];
        if (!subEventList) {
            return;
        }
        for (let i = subEventList.length - 1; i >= 0; i--) {
            if ((subEventList[i].context === context) && (subEventList[i].callback === callback)) {
                subEventList.splice(i, 1);
                break;
            }
        }
        if (subEventList.length == 0) {
            delete EventManager.Ins._eventMap[type];
        }
    }
    static offAll(context) {
        EventManager.Ins._eventMap.forEach((subEventList, type) => {
            for (let i = subEventList.length - 1; i >= 0; i--) {
                if ((subEventList[i].context === context)) {
                    subEventList.splice(i, 1);
                }
            }
            if (subEventList.length == 0) {
                delete EventManager.Ins._eventMap[type];
            }
        });
    }
}
exports.default = EventManager;

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameDefine_1 = require("./util/GameDefine");
class LogicScheduler {
    constructor() {
        this._isPause = false;
    }
    static get Ins() {
        if (!LogicScheduler._logicScheduler) {
            LogicScheduler._logicScheduler = new LogicScheduler();
            LogicScheduler._logicScheduler.init();
        }
        return LogicScheduler._logicScheduler;
    }
    init() {
        Laya.stage.frameRate = Laya.Stage.FRAME_FAST;
        LogicScheduler.frameRate = 0.0167;
        this._isPause = false;
        Laya.timer.frameLoop(1, this, this.onUpdate);
        this._compUpdataList = [];
        this._compLateUpdataList = [];
        this._callbackTimerList = [];
        this._frameCount = 0;
    }
    onUpdate() {
        if (this._isPause) {
            return;
        }
        let detal = Laya.timer.delta;
        let expect = 0;
        // 补帧
        while (detal > expect + LogicScheduler.frameRateFix) {
            this._frameCount++;
            this.onUpdateStep(LogicScheduler.frameRate);
            expect += (LogicScheduler.frameRate * 1000);
        }
    }
    onUpdateStep(detal) {
        for (let i = this._compUpdataList.length - 1; i >= 0; i--) {
            this._compUpdataList[i] && this._compUpdataList[i].update(detal);
        }
        for (let i = this._compLateUpdataList.length - 1; i >= 0; i--) {
            this._compLateUpdataList[i] && this._compLateUpdataList[i].lateUpdate(detal);
        }
        for (let i = this._callbackTimerList.length - 1; i >= 0; i--) {
            let callbackTimer = this._callbackTimerList[i];
            if (callbackTimer == null) {
                continue;
            }
            if (this._frameCount >= callbackTimer.executeFrame) {
                if (callbackTimer.executeCount === Number.MAX_VALUE) {
                    callbackTimer.executeFrame = callbackTimer.delayFrame + this._frameCount;
                }
                else {
                    callbackTimer.executeCount -= 1;
                    if (callbackTimer.executeCount <= 0) {
                        this._callbackTimerList.splice(i, 1);
                    }
                    else {
                        callbackTimer.executeFrame = callbackTimer.delayFrame + this._frameCount;
                    }
                }
                callbackTimer.callback.apply(callbackTimer.context, callbackTimer.args);
            }
        }
    }
    pause() {
        this._isPause = true;
    }
    resume() {
        this._isPause = false;
    }
    get isPause() {
        return this._isPause;
    }
    enableComp(component) {
        if (component.updateComp) {
            if (this._compUpdataList.indexOf(component) === -1) {
                this._compUpdataList.push(component);
            }
        }
        if (component.lateUpdateComp) {
            if (this._compLateUpdataList.indexOf(component) === -1) {
                this._compLateUpdataList.push(component);
            }
        }
    }
    disableComp(component) {
        if (this._compUpdataList.indexOf(component) !== -1) {
            this._compUpdataList.splice(this._compUpdataList.indexOf(component));
        }
        if (this._compLateUpdataList.indexOf(component) !== -1) {
            this._compLateUpdataList.splice(this._compLateUpdataList.indexOf(component));
        }
    }
    addToCallbackTimerList(context, callback, args, executeCount, delayFrame) {
        let executeFrame = delayFrame + this._frameCount;
        let callbackTimer = {
            context,
            callback,
            executeCount,
            args,
            delayFrame,
            executeFrame
        };
        this._callbackTimerList.push(callbackTimer);
    }
    clear(context, callback) {
        if (!context || !callback) {
            return;
        }
        for (let i = this._callbackTimerList.length - 1; i >= 0; i--) {
            if ((this._callbackTimerList[i].context === context) && (this._callbackTimerList[i].callback === callback)) {
                this._callbackTimerList.splice(i, 1);
            }
        }
    }
    clearAll(context) {
        if (!context) {
            return;
        }
        for (let i = this._callbackTimerList.length - 1; i >= 0; i--) {
            if (this._callbackTimerList[i].context === context) {
                this._callbackTimerList.splice(i, 1);
            }
        }
    }
    static loop(time, context, callback, args = null) {
        if (!callback || !context) {
            return;
        }
        LogicScheduler.Ins.clear(context, callback);
        let delayFrame = Math.ceil(time / GameDefine_1.FrameRate);
        LogicScheduler.Ins.addToCallbackTimerList(context, callback, args, Number.MAX_VALUE, delayFrame);
    }
    static loopFrame(frame, context, callback, args = null) {
        if (!callback || !context) {
            return;
        }
        LogicScheduler.Ins.clear(context, callback);
        LogicScheduler.Ins.addToCallbackTimerList(context, callback, args, Number.MAX_VALUE, frame);
    }
    static once(time, context, callback, args = null) {
        if (!callback || !context) {
            return;
        }
        LogicScheduler.Ins.clear(context, callback);
        let delayFrame = Math.ceil(time / GameDefine_1.FrameRate);
        LogicScheduler.Ins.addToCallbackTimerList(context, callback, args, 1, delayFrame);
    }
    static onceFrame(frame, context, callback, args = null) {
        if (!callback || !context) {
            return;
        }
        LogicScheduler.Ins.clear(context, callback);
        LogicScheduler.Ins.addToCallbackTimerList(context, callback, args, 1, frame);
    }
    static clear(context, callback) {
        LogicScheduler.Ins.clear(context, callback);
    }
    static clearAll(context) {
        LogicScheduler.Ins.clearAll(context);
    }
}
exports.default = LogicScheduler;
LogicScheduler.frameRate = 0.0167;
LogicScheduler.frameRateFix = 12;

},{"./util/GameDefine":36}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResLoader_1 = require("./util/ResLoader");
class SceneManager {
    static get Ins() {
        if (!SceneManager._sceneManager) {
            SceneManager._sceneManager = new SceneManager();
        }
        return SceneManager._sceneManager;
    }
    static get curSence() {
        return SceneManager.Ins._curSence;
    }
    static open(scene, loading = true, clear = true) {
        let sceneManager = SceneManager.Ins;
        if (sceneManager._curSence && clear) {
            sceneManager._curSence.onDestory();
        }
        sceneManager._curSence = new scene();
        if (loading) {
            sceneManager.loadScene(sceneManager._curSence.dependAssets());
        }
        else {
            sceneManager._curSence.onLoad();
        }
    }
    static setLoadScene(scene) {
        let sceneManager = SceneManager.Ins;
        sceneManager._loadName = scene;
        if (sceneManager._loadScene) {
            sceneManager._loadScene.onDestory();
        }
        sceneManager._loadScene = null;
    }
    loadScene(urls) {
        if (this._loadScene) {
            this._loadScene.show();
            this._loadScene.loadUrls(urls, this, this.loadComplete);
        }
        else {
            this._loadScene = new this._loadName();
            ResLoader_1.default.load(this._loadScene.dependAssets(), this, () => {
                this._loadScene.onLoad();
                this._loadScene.loadUrls(urls, this, this.loadComplete);
            });
        }
    }
    loadComplete() {
        this._curSence.onLoad();
    }
}
exports.default = SceneManager;

},{"./util/ResLoader":41}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TriggerCollisionScript extends Laya.Script3D {
    constructor() {
        super();
    }
    onTriggerEnter(other) {
        // log("onTriggerEnter");
        this._triggerEnterFuntion && this._triggerEnterFuntion.call(this._triggerEnterCaller, other);
    }
    onTriggerStay(other) {
        // log("onTriggerStay");
        this._triggerStayFuntion && this._triggerStayFuntion.call(this._triggerStayCaller, other);
    }
    onTriggerExit(other) {
        // log("onTriggerExit");  
        this._triggerExitFuntion && this._triggerExitFuntion.call(this._triggerExitCaller, other);
    }
    onCollisionEnter(collision) {
        // log("onCollisionEnter");  
        // if (collision.other.owner.name == "block") {
        // }
        this._collisionEnterFuntion && this._collisionEnterFuntion.call(this._collisionEnterCaller, collision);
    }
    onCollisionStay(collision) {
        // if (collision.other.owner.name == "block") {
        //     log("onCollisionStay"); 
        // }
        this._collisionStayFuntion && this._collisionStayFuntion.call(this._collisionStayCaller, collision);
    }
    onCollisionExit(collision) {
        // log("onCollisionExit");  
        // if (collision.other.owner.name == "block") {
        // }
        this._collisionExitFuntion && this._collisionExitFuntion.call(this._collisionExitCaller, collision);
    }
    setCollisionEnter(context, callBack) {
        this._collisionEnterCaller = context;
        this._collisionEnterFuntion = callBack;
    }
    setCollisionStay(context, callBack) {
        this._collisionStayCaller = context;
        this._collisionStayFuntion = callBack;
    }
    setCollisionExit(context, callBack) {
        this._collisionExitCaller = context;
        this._collisionExitFuntion = callBack;
    }
    setTriggerEnter(context, callBack) {
        this._triggerEnterCaller = context;
        this._triggerEnterFuntion = callBack;
    }
    setTriggerStay(context, callBack) {
        this._triggerStayCaller = context;
        this._triggerStayFuntion = callBack;
    }
    setTriggerExit(context, callBack) {
        this._triggerExitCaller = context;
        this._triggerExitFuntion = callBack;
    }
    onDestroy() {
        super.onDestroy();
        this._collisionEnterCaller = null;
        this._collisionEnterFuntion = null;
        this._collisionStayCaller = null;
        this._collisionStayFuntion = null;
        this._collisionExitCaller = null;
        this._collisionExitFuntion = null;
        this._triggerEnterCaller = null;
        this._triggerEnterFuntion = null;
        this._triggerStayCaller = null;
        this._triggerStayFuntion = null;
        this._triggerExitCaller = null;
        this._triggerExitFuntion = null;
    }
}
exports.default = TriggerCollisionScript;

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewOrder = void 0;
const BaseEntity_1 = require("./BaseEntity");
var ViewOrder;
(function (ViewOrder) {
    ViewOrder[ViewOrder["Low"] = 0] = "Low";
    ViewOrder[ViewOrder["Middle"] = 100] = "Middle";
    ViewOrder[ViewOrder["High"] = 200] = "High";
})(ViewOrder = exports.ViewOrder || (exports.ViewOrder = {}));
class ViewManager {
    constructor() {
        this._uiPanel = fgui.GRoot.inst.displayObject;
        Laya.stage.addChild(fgui.GRoot.inst.displayObject);
        this._uiPanel.zOrder = 10;
    }
    static get Ins() {
        if (!ViewManager._viewManager) {
            ViewManager._viewManager = new ViewManager();
        }
        return ViewManager._viewManager;
    }
    static getUiPanel() {
        return ViewManager.Ins._uiPanel;
    }
    static addView(view, ...params) {
        let viewManager = ViewManager.Ins;
        let curEntity = new BaseEntity_1.default();
        let curView = curEntity.addComponent(view, params);
        viewManager._uiPanel.addChild(curView.view.displayObject);
        return curView;
    }
    static removeView(view) {
        let viewManager = ViewManager.Ins;
        viewManager._uiPanel.removeChild(view.view.displayObject);
        view.onDestory();
    }
    static removeAllView() {
        let viewManager = ViewManager.Ins;
        viewManager._uiPanel && viewManager._uiPanel.removeChildren();
    }
}
exports.default = ViewManager;

},{"./BaseEntity":5}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogicScheduler_1 = require("../LogicScheduler");
class Action {
    constructor() {
        this.originalTarget = null;
        this.target = null;
        this.tag = -1;
    }
    /**
     * !#en
     * return true if the action has finished.
     * !#zh 如果动作已完成就返回 true。
     * @method isDone
     * @return {Boolean}
     */
    isDone() {
        return true;
    }
    // called before the action start. It will also set the target.
    startWithTarget(target) {
        this.originalTarget = target;
        this.target = target;
    }
    // called after the action has finished. It will set the 'target' to nil.
    stop() {
        this.target = null;
    }
    // called every frame with it's delta time. <br />
    step(t) {
    }
    update(t) {
    }
    /**
     * !#en get the target.
     * !#zh 获取当前目标节点。
     * @method getTarget
     * @return {Node}
     */
    getTarget() {
        return this.target;
    }
    /**
     * !#en The action will modify the target properties.
     * !#zh 设置目标节点。
     * @method setTarget
     * @param {Node} target
     */
    setTarget(target) {
        this.target = target;
    }
    /**
     * !#en get the original target.
     * !#zh 获取原始目标节点。
     * @method getOriginalTarget
     * @return {Node}
     */
    getOriginalTarget() {
        return this.originalTarget;
    }
    // Set the original target, since target can be nil.
    // Is the target that were used to run the action.
    // Unless you are doing something complex, like cc.ActionManager, you should NOT call this method.
    setOriginalTarget(originalTarget) {
        this.originalTarget = originalTarget;
    }
    /**
     * !#en get tag number.
     * !#zh 获取用于识别动作的标签。
     * @method getTag
     * @return {Number}
     */
    getTag() {
        return this.tag;
    }
    /**
     * !#en set tag number.
     * !#zh 设置标签，用于识别动作。
     * @method setTag
     * @param {Number} tag
     */
    setTag(tag) {
        this.tag = tag;
    }
    // Currently JavaScript Bindigns (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
    // and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
    // This is a hack, and should be removed once JSB fixes the retain/release bug.
    retain() {
    }
    // Currently JavaScript Bindigns (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
    // and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
    // This is a hack, and should be removed once JSB fixes the retain/release bug.
    release() {
    }
    onDestory() {
        this.originalTarget = null;
        this.target = null;
        this.tag = -1;
    }
}
exports.default = Action;
// 浮点数最小值
Action.FLT_EPSILON = 0.0000001192092896;
// 帧率
Action.FRAME_RATE = LogicScheduler_1.default.frameRate;
Action.ENABLE_STACKABLE_ACTIONS = true;

},{"../LogicScheduler":12}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseBezier = exports.EaseBackInOut = exports.EaseBackOut = exports.EaseBackIn = exports.EaseBounceInOut = exports.EaseBounceOut = exports.EaseBounceIn = exports.easeElasticInOut = exports.EaseElasticOut = exports.EaseElasticIn = exports.EaseSineInOut = exports.EaseSineOut = exports.EaseSineIn = exports.EaseExponentialInOut = exports.EaseExponentialOut = exports.EaseExponentialIn = exports.EaseInOut = exports.EaseOut = exports.EaseIn = exports.ActionEase = void 0;
class ActionEase {
    constructor() {
    }
}
exports.ActionEase = ActionEase;
class EaseIn extends ActionEase {
    constructor(rate) {
        super();
        this._rate = rate;
    }
    easing(dt) {
        return Math.pow(dt, this._rate);
    }
    reverse() {
        return new EaseIn(1 / this._rate);
    }
}
exports.EaseIn = EaseIn;
/**
 * 创建 easeOut 缓动对象，由快到慢。
 */
class EaseOut extends ActionEase {
    constructor(rate) {
        super();
        this._rate = rate;
    }
    easing(dt) {
        return Math.pow(dt, 1 / this._rate);
    }
    reverse() {
        return new EaseOut(1 / this._rate);
    }
}
exports.EaseOut = EaseOut;
/**
 * 创建 easeInOut 缓动对象，慢到快，然后慢。
 */
class EaseInOut extends ActionEase {
    constructor(rate) {
        super();
        this._rate = rate;
    }
    easing(dt) {
        dt *= 2;
        if (dt < 1)
            return 0.5 * Math.pow(dt, this._rate);
        else
            return 1.0 - 0.5 * Math.pow(2 - dt, this._rate);
    }
    reverse() {
        return new EaseInOut(1 / this._rate);
    }
}
exports.EaseInOut = EaseInOut;
class EaseExponentialIn extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return dt === 0 ? 0 : Math.pow(2, 10 * (dt - 1));
    }
    reverse() {
        return new EaseExponentialOut();
    }
}
exports.EaseExponentialIn = EaseExponentialIn;
class EaseExponentialOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return dt === 1 ? 1 : (-(Math.pow(2, -10 * dt)) + 1);
    }
    reverse() {
        return new EaseExponentialIn();
    }
}
exports.EaseExponentialOut = EaseExponentialOut;
class EaseExponentialInOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        if (dt !== 1 && dt !== 0) {
            dt *= 2;
            if (dt < 1)
                return 0.5 * Math.pow(2, 10 * (dt - 1));
            else
                return 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
        }
        return dt;
    }
    reverse() {
        return new EaseExponentialInOut();
    }
}
exports.EaseExponentialInOut = EaseExponentialInOut;
class EaseSineIn extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return (dt === 0 || dt === 1) ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
    }
    reverse() {
        return new EaseSineOut();
    }
}
exports.EaseSineIn = EaseSineIn;
class EaseSineOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return (dt === 0 || dt === 1) ? dt : Math.sin(dt * Math.PI / 2);
    }
    reverse() {
        return new EaseSineIn();
    }
}
exports.EaseSineOut = EaseSineOut;
class EaseSineInOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return (dt === 0 || dt === 1) ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
    }
    reverse() {
        return new EaseSineInOut();
    }
}
exports.EaseSineInOut = EaseSineInOut;
/**
 * EaseElasticIn 是按弹性曲线缓动进入的动作。<br />
 */
class EaseElasticIn extends ActionEase {
    constructor(period) {
        super();
        this._period = period;
    }
    easing(dt) {
        if (dt === 0 || dt === 1)
            return dt;
        dt = dt - 1;
        return -Math.pow(2, 10 * dt) * Math.sin((dt - (this._period / 4)) * Math.PI * 2 / this._period);
    }
    reverse() {
        return new EaseElasticOut(this._period);
    }
}
exports.EaseElasticIn = EaseElasticIn;
class EaseElasticOut extends ActionEase {
    constructor(period) {
        super();
        this._period = period;
    }
    easing(dt) {
        return (dt === 0 || dt === 1) ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - (this._period / 4)) * Math.PI * 2 / this._period) + 1;
    }
    reverse() {
        return new EaseElasticIn(this._period);
    }
}
exports.EaseElasticOut = EaseElasticOut;
class easeElasticInOut extends ActionEase {
    constructor(period) {
        super();
        this._period = period;
    }
    easing(dt) {
        let newT = 0;
        let locPeriod = this._period;
        if (dt === 0 || dt === 1) {
            newT = dt;
        }
        else {
            dt = dt * 2;
            if (!locPeriod)
                locPeriod = this._period = 0.3 * 1.5;
            let s = locPeriod / 4;
            dt = dt - 1;
            if (dt < 0)
                newT = -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
            else
                newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * 0.5 + 1;
        }
        return newT;
    }
    reverse() {
        return new easeElasticInOut(this._period);
    }
}
exports.easeElasticInOut = easeElasticInOut;
function bounceTime(dt) {
    if (dt < 1 / 2.75) {
        return 7.5625 * dt * dt;
    }
    else if (dt < 2 / 2.75) {
        dt -= 1.5 / 2.75;
        return 7.5625 * dt * dt + 0.75;
    }
    else if (dt < 2.5 / 2.75) {
        dt -= 2.25 / 2.75;
        return 7.5625 * dt * dt + 0.9375;
    }
    dt -= 2.625 / 2.75;
    return 7.5625 * dt * dt + 0.984375;
}
class EaseBounceIn extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return 1 - bounceTime(1 - dt);
    }
    reverse() {
        return new EaseBounceOut();
    }
}
exports.EaseBounceIn = EaseBounceIn;
class EaseBounceOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        return bounceTime(dt);
    }
    reverse() {
        return new EaseBounceIn();
    }
}
exports.EaseBounceOut = EaseBounceOut;
class EaseBounceInOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        let newT;
        if (dt < 0.5) {
            dt = dt * 2;
            newT = (1 - bounceTime(1 - dt)) * 0.5;
        }
        else {
            newT = bounceTime(dt * 2 - 1) * 0.5 + 0.5;
        }
        return newT;
    }
    reverse() {
        return new EaseBounceInOut();
    }
}
exports.EaseBounceInOut = EaseBounceInOut;
class EaseBackIn extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        let overshoot = 1.70158;
        return (dt === 0 || dt === 1) ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
    }
    reverse() {
        return new EaseBackOut();
    }
}
exports.EaseBackIn = EaseBackIn;
class EaseBackOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        let overshoot = 1.70158;
        dt = dt - 1;
        return dt * dt * ((overshoot + 1) * dt + overshoot) + 1;
    }
    reverse() {
        return new EaseBackIn();
    }
}
exports.EaseBackOut = EaseBackOut;
class EaseBackInOut extends ActionEase {
    constructor() {
        super();
    }
    easing(dt) {
        let overshoot = 1.70158 * 1.525;
        dt = dt * 2;
        if (dt < 1) {
            return (dt * dt * ((overshoot + 1) * dt - overshoot)) / 2;
        }
        else {
            dt = dt - 2;
            return (dt * dt * ((overshoot + 1) * dt + overshoot)) / 2 + 1;
        }
    }
    reverse() {
        return new EaseBackInOut();
    }
}
exports.EaseBackInOut = EaseBackInOut;
class EaseBezier extends ActionEase {
    constructor(a, b, c, d) {
        super();
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
    easing(dt) {
        return (Math.pow(1 - dt, 3) * this.a + 3 * dt * (Math.pow(1 - dt, 2)) * this.b + 3 * Math.pow(dt, 2) * (1 - dt) * this.c + Math.pow(dt, 3) * this.d);
    }
    reverse() {
        return new EaseBezier(this.d, this.c, this.b, this.a);
    }
}
exports.EaseBezier = EaseBezier;

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogicScheduler_1 = require("../LogicScheduler");
const Action_1 = require("./Action");
class HashElement {
    constructor() {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = false;
        this.lock = false;
    }
}
class ActionManager {
    constructor() {
        this._elementPool = [];
        this._hashTargets = new Map();
        this._arrayTargets = [];
        this._currentTarget = null;
        LogicScheduler_1.default.loopFrame(1, this, this.update);
    }
    static get Ins() {
        if (!ActionManager._ActionManager) {
            ActionManager._ActionManager = new ActionManager();
        }
        return ActionManager._ActionManager;
    }
    getElement(target, paused) {
        let element = this._elementPool.pop();
        if (!element) {
            element = new HashElement();
        }
        element.target = target;
        element.paused = !!paused;
        return element;
    }
    putElement(element) {
        element.actions.length = 0;
        element.actionIndex = 0;
        element.currentAction = null;
        element.paused = false;
        element.target = null;
        element.lock = false;
        this._elementPool.push(element);
    }
    /**
     * 增加一个动作，同时还需要提供动作的目标对象，目标对象是否暂停作为参数。<br/>
     * 如果目标已存在，动作将会被直接添加到现有的节点中。<br/>
     * 如果目标不存在，将为这一目标创建一个新的实例，并将动作添加进去。<br/>
     * 当目标状态的 paused 为 true，动作将不会被执行
     */
    addAction(action, target, paused = false) {
        if (!action || !target) {
            return;
        }
        //check if the action target already exists
        let element = this._hashTargets[target.uuid];
        //if doesn't exists, create a hashelement and push in mpTargets
        if (!element) {
            element = this.getElement(target, paused);
            this._hashTargets[target.uuid] = element;
            this._arrayTargets.push(element);
        }
        else if (!element.actions) {
            element.actions = [];
        }
        element.actions.push(action);
        action.startWithTarget(target);
    }
    static addAction(action, target, paused = false) {
        ActionManager.Ins.addAction(action, target, paused);
    }
    /**
     * 移除所有对象的所有动作。
     * @method removeAllActions
     */
    removeAllActions() {
        let locTargets = this._arrayTargets;
        for (let i = 0; i < locTargets.length; i++) {
            let element = locTargets[i];
            if (element)
                this.putElement(element);
        }
        this._arrayTargets.length = 0;
        this._hashTargets.clear();
    }
    /**
     * 移除指定对象上的所有动作。<br/>
     * 属于该目标的所有的动作将被删除。
     */
    removeAllActionsFromTarget(target) {
        if (target == null)
            return;
        let element = this._hashTargets[target.uuid];
        if (element) {
            element.actions.length = 0;
            this.deleteHashElement(element);
        }
    }
    static removeAllActionsFromTarget(target) {
        ActionManager.Ins.removeAllActionsFromTarget(target);
    }
    /**
     * 移除指定的动作。
     */
    removeAction(action) {
        // explicit null handling
        if (action == null)
            return;
        let target = action.getOriginalTarget();
        let element = this._hashTargets[target.uuid];
        if (element) {
            for (let i = 0; i < element.actions.length; i++) {
                if (element.actions[i] === action) {
                    action.onDestory();
                    element.actions.splice(i, 1);
                    // update actionIndex in case we are in tick. looping over the actions
                    if (element.actionIndex >= i)
                        element.actionIndex--;
                    break;
                }
            }
        }
        else {
        }
    }
    /**
     * 删除指定对象下特定标签的一个动作，将删除首个匹配到的动作。
     */
    removeActionByTag(tag, target) {
        let element = this._hashTargets[target.uuid];
        if (element) {
            let limit = element.actions.length;
            for (let i = 0; i < limit; ++i) {
                let action = element.actions[i];
                if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
                    action.onDestory();
                    this.removeActionAtIndex(i, element);
                    break;
                }
            }
        }
    }
    /**
     * !#zh 通过目标对象和标签获取一个动作。
     * @method getActionByTag
     * @param {Number} tag
     * @param {Node} target
     * @return {Action|Null}  return the Action with the given tag on success
     */
    getActionByTag(tag, target) {
        let element = this._hashTargets[target.uuid];
        if (element) {
            if (element.actions != null) {
                for (let i = 0; i < element.actions.length; ++i) {
                    let action = element.actions[i];
                    if (action && action.getTag() === tag)
                        return action;
                }
            }
        }
        return null;
    }
    /**
     * 返回指定对象下所有正在运行的动作数量。 <br/>
     * 组合动作被算作一个动作。<br/>
     * 例如：<br/>
     *  - 如果您正在运行 7 个动作组成的序列动作（Sequence），这个函数将返回 1。<br/>
     *  - 如果你正在运行 2 个序列动作（Sequence）和 5 个普通动作，这个函数将返回 7。<br/>
     *
     * @method getNumberOfRunningActionsInTarget
     * @param {Node} target
     * @return {Number}
     */
    getNumberOfRunningActionsInTarget(target) {
        let element = this._hashTargets[target.uuid];
        if (element)
            return (element.actions) ? element.actions.length : 0;
        return 0;
    }
    /**
     * 暂停指定对象：所有正在运行的动作和新添加的动作都将会暂停。
     * @method pauseTarget
     * @param {Node} target
     */
    pauseTarget(target) {
        let element = this._hashTargets[target.uuid];
        if (element)
            element.paused = true;
    }
    /**
     * 让指定目标恢复运行。在执行序列中所有被暂停的动作将重新恢复运行。
     * @method resumeTarget
     * @param {Node} target
     */
    resumeTarget(target) {
        let element = this._hashTargets[target.uuid];
        if (element)
            element.paused = false;
    }
    /**
     * 暂停所有正在运行的动作，返回一个包含了那些动作被暂停了的目标对象的列表。
     * @method pauseAllRunningActions
     * @return {Array}  a list of targets whose actions were paused.
     */
    pauseAllRunningActions() {
        let idsWithActions = [];
        let locTargets = this._arrayTargets;
        for (let i = 0; i < locTargets.length; i++) {
            let element = locTargets[i];
            if (element && !element.paused) {
                element.paused = true;
                idsWithActions.push(element.target);
            }
        }
        return idsWithActions;
    }
    /**
     * 让一组指定对象恢复运行（用来逆转 pauseAllRunningActions 效果的便捷函数）。
     * @method resumeTargets
     * @param {Array} targetsToResume
     */
    resumeTargets(targetsToResume) {
        if (!targetsToResume)
            return;
        for (let i = 0; i < targetsToResume.length; i++) {
            if (targetsToResume[i])
                this.resumeTarget(targetsToResume[i]);
        }
    }
    /**
     * !#zh 暂停一组指定对象。
     * @method pauseTargets
     * @param {Array} targetsToPause
     */
    pauseTargets(targetsToPause) {
        if (!targetsToPause)
            return;
        for (let i = 0; i < targetsToPause.length; i++) {
            if (targetsToPause[i])
                this.pauseTarget(targetsToPause[i]);
        }
    }
    /**
     * 清除共用的动作管理器。它释放了持有的实例。 <br/>
     * 因为它使用 this，因此它不能是静态的。
     * @method purgeSharedManager
     */
    purgeSharedManager() {
        LogicScheduler_1.default.clearAll(this);
    }
    removeActionAtIndex(index, element) {
        element.actions.splice(index, 1);
        // update actionIndex in case we are in tick. looping over the actions
        if (element.actionIndex >= index)
            element.actionIndex--;
        if (element.actions.length === 0) {
            this.deleteHashElement(element);
        }
    }
    deleteHashElement(element) {
        let ret = false;
        if (element && !element.lock) {
            if (this._hashTargets[element.target.uuid]) {
                delete this._hashTargets[element.target.uuid];
                let targets = this._arrayTargets;
                for (let i = 0, l = targets.length; i < l; i++) {
                    if (targets[i] === element) {
                        targets.splice(i, 1);
                        break;
                    }
                }
                this.putElement(element);
                ret = true;
            }
        }
        return ret;
    }
    /**
     * ActionManager 主循环。
     * @method update
     */
    update() {
        let dt = Action_1.default.FRAME_RATE;
        let locTargets = this._arrayTargets;
        for (let elt = 0; elt < locTargets.length; elt++) {
            this._currentTarget = locTargets[elt];
            let locCurrTarget = this._currentTarget;
            if (!locCurrTarget.paused && locCurrTarget.actions) {
                locCurrTarget.lock = true;
                for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                    locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                    if (!locCurrTarget.currentAction)
                        continue;
                    //use for speed
                    locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));
                    if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                        locCurrTarget.currentAction.stop();
                        let action = locCurrTarget.currentAction;
                        // Make currentAction nil to prevent removeAction from salvaging it.
                        locCurrTarget.currentAction = null;
                        this.removeAction(action);
                    }
                    locCurrTarget.currentAction = null;
                }
                locCurrTarget.lock = false;
            }
            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)
            if (locCurrTarget.actions.length === 0) {
                this.deleteHashElement(locCurrTarget) && elt--;
            }
        }
    }
}
exports.default = ActionManager;

},{"../LogicScheduler":12,"./Action":16}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InstantAction_1 = require("./InstantAction");
class CallFuncAction extends InstantAction_1.default {
    constructor(selector, selectorTarget, data) {
        super();
        this._selectorTarget = null;
        this._function = null;
        this._data = null;
        this.initWithFunction(selector, selectorTarget, data);
    }
    initWithFunction(selector, selectorTarget, data) {
        if (selector) {
            this._function = selector;
        }
        if (selectorTarget) {
            this._selectorTarget = selectorTarget;
        }
        if (data !== undefined) {
            this._data = data;
        }
        return true;
    }
    execute() {
        if (this._function) {
            this._function.call(this._selectorTarget, this.target, this._data);
        }
    }
    update(dt) {
        this.execute();
    }
    getTargetCallback() {
        return this._selectorTarget;
    }
    setTargetCallback(sel) {
        if (sel !== this._selectorTarget) {
            if (this._selectorTarget)
                this._selectorTarget = null;
            this._selectorTarget = sel;
        }
    }
    onDestory() {
        super.onDestory();
        this._selectorTarget = null;
        this._function = null;
        this._data = null;
    }
}
exports.default = CallFuncAction;

},{"./InstantAction":21}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 有限时间动作，这种动作拥有时长 duration 属性。
 */
const Action_1 = require("./Action");
class FiniteTimeAction extends Action_1.default {
    constructor() {
        super();
        this._duration = 0;
    }
    getDuration() {
        return this._duration;
    }
    reverse() {
        return this;
    }
    /**
     * !#en set duration of the action. (seconds).
     * !#zh 设置动作以秒为单位的持续时间。
     * @method setDuration
     * @param {Number} duration
     */
    setDuration(duration) {
        this._duration = duration;
    }
}
exports.default = FiniteTimeAction;

},{"./Action":16}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 即时动作，这种动作立即就会执行，继承自 FiniteTimeAction。
 */
const FiniteTimeAction_1 = require("./FiniteTimeAction");
class InstantAction extends FiniteTimeAction_1.default {
    constructor() {
        super();
    }
    isDone() {
        return true;
    }
    step() {
        this.update(1);
    }
    update(dt) {
        //nothing
    }
}
exports.default = InstantAction;

},{"./FiniteTimeAction":20}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 时间间隔动作，这种动作在已定时间内完成，继承 FiniteTimeAction。
 */
const FiniteTimeAction_1 = require("./FiniteTimeAction");
const Action_1 = require("./Action");
class IntervalAction extends FiniteTimeAction_1.default {
    constructor(d) {
        super();
        this.MAX_VALUE = 2;
        this._elapsed = 0;
        this._firstTick = false;
        this._easeList = null;
        this._speed = 1;
        this._timesForRepeat = 1;
        this._repeatForever = false;
        d !== undefined && this.initWithDuration(d);
    }
    getElapsed() {
        return this._elapsed;
    }
    initWithDuration(d) {
        this._duration = (d === 0) ? Action_1.default.FLT_EPSILON : d;
        // prevent division by 0
        // This comparison could be in step:, but it might decrease the performance
        // by 3% in heavy based action games.
        this._elapsed = 0;
        this._firstTick = true;
        return true;
    }
    startWithTarget(target) {
        super.startWithTarget(target);
        this._elapsed = 0;
        this._firstTick = true;
    }
    cloneDecoration(action) {
        action._repeatForever = this._repeatForever;
        action._speed = this._speed;
        action._timesForRepeat = this._timesForRepeat;
        action._easeList = this._easeList;
    }
    isDone() {
        return (this._elapsed >= this._duration);
    }
    reverseEaseList(action) {
        if (this._easeList) {
            action._easeList = [];
            for (let i = 0; i < this._easeList.length; i++) {
                action._easeList.push(this._easeList[i].reverse());
            }
        }
    }
    /**
     * 缓动运动。
     * @method easing
     * @param {Object} easeObj
     * @returns {ActionInterval}
     * @example
     * action.easing(cc.easeIn(3.0));
     */
    easing(easeObj) {
        if (this._easeList)
            this._easeList.length = 0;
        else
            this._easeList = [];
        for (let i = 0; i < arguments.length; i++)
            this._easeList.push(arguments[i]);
        return this;
    }
    computeEaseTime(dt) {
        let locList = this._easeList;
        if ((!locList) || (locList.length === 0))
            return dt;
        for (let i = 0, n = locList.length; i < n; i++)
            dt = locList[i].easing(dt);
        return dt;
    }
    step(dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
        }
        else if (dt !== undefined) {
            this._elapsed += dt;
        }
        else {
            this._elapsed += Action_1.default.FRAME_RATE;
        }
        let t = this._elapsed / (this._duration > Action_1.default.FLT_EPSILON ? this._duration : Action_1.default.FLT_EPSILON);
        t = (1 > t ? t : 1);
        this.update(t > 0 ? t : 0);
    }
    reverse() {
        return null;
    }
    /*
     * Get amplitude rate.
     * @warning It should be overridden in subclass.
     * @return {Number} 0
     */
    getAmplitudeRate() {
        return 0;
    }
    /**
     * 改变一个动作的速度，使它的执行使用更长的时间（speed > 1）<br/>
     * 或更少（speed < 1）可以有效得模拟“慢动作”或“快进”的效果。
     * @param {Number} speed
     * @returns {Action}
     */
    speed(speed) {
        if (speed <= 0) {
            return this;
        }
        this._speed *= speed;
        return this;
    }
    /**
     * Get this action speed.
     * @return {Number}
     */
    getSpeed() {
        return this._speed;
    }
    /**
     * Set this action speed.
     * @param {Number} speed
     * @returns {ActionInterval}
     */
    setSpeed(speed) {
        this._speed = speed;
        return this;
    }
    /**
     * 重复动作可以按一定次数重复一个动作，使用 RepeatForever 动作来永远重复一个动作。
     * @method repeat
     * @param {Number} times
     * @returns {ActionInterval}
     */
    repeat(times) {
        times = Math.round(times);
        if (isNaN(times) || times < 1) {
            return this;
        }
        this._timesForRepeat *= times;
        return this;
    }
    /**
     * !#en
     * Repeats an action for ever.  <br/>
     * To repeat the an action for a limited number of times use the Repeat action. <br/>
     * !#zh 永远地重复一个动作，有限次数内重复一个动作请使用 Repeat 动作。
     * @method repeatForever
     * @returns {ActionInterval}
     */
    repeatForever() {
        this._timesForRepeat = this.MAX_VALUE;
        return this;
    }
    onDestory() {
        super.onDestory();
        this._easeList && (this._easeList.length = 0);
    }
}
exports.default = IntervalAction;

},{"./Action":16,"./FiniteTimeAction":20}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IntervalAction_1 = require("./IntervalAction");
const Action_1 = require("./Action");
class MoveByAction extends IntervalAction_1.default {
    constructor(duration, deltaPos) {
        super(duration);
        this._positionDelta = new Laya.Vector3(0, 0, 0);
        this._startPosition = new Laya.Vector3(0, 0, 0);
        this._previousPosition = new Laya.Vector3(0, 0, 0);
        deltaPos !== undefined && this.initCurWithDuration(duration, deltaPos);
    }
    initCurWithDuration(duration, position) {
        if (super.initWithDuration(duration)) {
            this._positionDelta = position;
            return true;
        }
        return false;
    }
    startWithTarget(target) {
        super.startWithTarget(target);
        let locPosX = target.model.localPosition.x;
        let locPosY = target.model.localPosition.y;
        let locPosZ = target.model.localPosition.z;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._previousPosition.z = locPosZ;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
        this._startPosition.z = locPosZ;
    }
    update(dt) {
        dt = super.computeEaseTime(dt);
        if (this.target) {
            let x = this._positionDelta.x * dt;
            let y = this._positionDelta.y * dt;
            let z = this._positionDelta.z * dt;
            let locStartPosition = this._startPosition;
            if (Action_1.default.ENABLE_STACKABLE_ACTIONS) {
                let targetX = this.target.model.localPosition.x;
                let targetY = this.target.model.localPosition.y;
                let targetZ = this.target.model.localPosition.z;
                locStartPosition.x = locStartPosition.x + targetX - this._previousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - this._previousPosition.y;
                locStartPosition.z = locStartPosition.z + targetZ - this._previousPosition.z;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
                z = z + locStartPosition.z;
                this._previousPosition.x = x;
                this._previousPosition.y = y;
                this._previousPosition.z = z;
                this.target.model.setPosition(x, y, z);
            }
            else {
                this.target.model.setPosition(locStartPosition.x + x, locStartPosition.y + y, locStartPosition.z + z);
            }
        }
    }
    reverse() {
        let action = new MoveByAction(this._duration, new Laya.Vector3(-this._positionDelta.x, -this._positionDelta.y, -this._positionDelta.z));
        this.cloneDecoration(action);
        this.reverseEaseList(action);
        return action;
    }
}
exports.default = MoveByAction;

},{"./Action":16,"./IntervalAction":22}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IntervalAction_1 = require("./IntervalAction");
const Action_1 = require("./Action");
class RotateByAction extends IntervalAction_1.default {
    constructor(duration, deltaAngle) {
        super(duration);
        this._angleDelta = new Laya.Vector3(0, 0, 0);
        this._startAngle = new Laya.Vector3(0, 0, 0);
        this._previousAngle = new Laya.Vector3(0, 0, 0);
        deltaAngle !== undefined && this.initCurWithDuration(duration, deltaAngle);
    }
    initCurWithDuration(duration, angle) {
        if (super.initWithDuration(duration)) {
            this._angleDelta = angle;
            return true;
        }
        return false;
    }
    startWithTarget(target) {
        super.startWithTarget(target);
        let locAngleX = target.model.localRotationEuler.x;
        let locAngleY = target.model.localRotationEuler.y;
        let locAngleZ = target.model.localRotationEuler.z;
        this._previousAngle.x = locAngleX;
        this._previousAngle.y = locAngleY;
        this._previousAngle.z = locAngleZ;
        this._startAngle.x = locAngleX;
        this._startAngle.y = locAngleY;
        this._startAngle.z = locAngleZ;
    }
    update(dt) {
        dt = super.computeEaseTime(dt);
        if (this.target) {
            let x = this._angleDelta.x * dt;
            let y = this._angleDelta.y * dt;
            let z = this._angleDelta.z * dt;
            let locStartAngle = this._startAngle;
            if (Action_1.default.ENABLE_STACKABLE_ACTIONS) {
                let targetX = this.target.model.localRotationEuler.x;
                let targetY = this.target.model.localRotationEuler.y;
                let targetZ = this.target.model.localRotationEuler.z;
                locStartAngle.x = locStartAngle.x + targetX - this._previousAngle.x;
                locStartAngle.y = locStartAngle.y + targetY - this._previousAngle.y;
                locStartAngle.z = locStartAngle.z + targetZ - this._previousAngle.z;
                x = x + locStartAngle.x;
                y = y + locStartAngle.y;
                z = z + locStartAngle.z;
                this._previousAngle.x = x;
                this._previousAngle.y = y;
                this._previousAngle.z = z;
                this.target.model.setRotation(x, y, z);
            }
            else {
                this.target.model.setRotation(locStartAngle.x + x, locStartAngle.y + y, locStartAngle.z + z);
            }
        }
    }
    reverse() {
        let action = new RotateByAction(this._duration, new Laya.Vector3(-this._angleDelta.x, -this._angleDelta.y, -this._angleDelta.z));
        this.cloneDecoration(action);
        this.reverseEaseList(action);
        return action;
    }
}
exports.default = RotateByAction;

},{"./Action":16,"./IntervalAction":22}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RotateByAction_1 = require("./RotateByAction");
class RotateToAction extends RotateByAction_1.default {
    constructor(duration, angle) {
        super(duration, angle);
        angle !== undefined && this.initCurWithDuration(duration, angle);
    }
    initCurWithDuration(duration, angle) {
        if (super.initWithDuration(duration)) {
            this._endAngle = angle;
            return true;
        }
        return false;
    }
    startWithTarget(target) {
        super.startWithTarget(target);
        let tarPos = target.model.localRotationEuler;
        let locDiffAngleX = this._endAngle.x - tarPos.x;
        if (locDiffAngleX > 180) {
            locDiffAngleX -= 360;
        }
        if (locDiffAngleX < -180) {
            locDiffAngleX += 360;
        }
        this._angleDelta.x = locDiffAngleX;
        let locDiffAngleY = this._endAngle.y - tarPos.y;
        if (locDiffAngleY > 180) {
            locDiffAngleY -= 360;
        }
        if (locDiffAngleY < -180) {
            locDiffAngleY += 360;
        }
        this._angleDelta.y = locDiffAngleY;
        let locDiffAngleZ = this._endAngle.z - tarPos.z;
        if (locDiffAngleZ > 180) {
            locDiffAngleZ -= 360;
        }
        if (locDiffAngleZ < -180) {
            locDiffAngleZ += 360;
        }
        this._angleDelta.z = locDiffAngleZ;
    }
}
exports.default = RotateToAction;

},{"./RotateByAction":24}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IntervalAction_1 = require("./IntervalAction");
class SequenceAction extends IntervalAction_1.default {
    constructor(tempArray) {
        super();
        this._actions = [];
        this._last = 0;
        this._reversed = false;
        let paramArray = (tempArray instanceof Array) ? tempArray : arguments;
        if (paramArray.length === 1) {
            return;
        }
        let last = paramArray.length - 1;
        if (last >= 0) {
            let prev = paramArray[0], action1;
            for (let i = 1; i < last; i++) {
                if (paramArray[i]) {
                    action1 = prev;
                    prev = SequenceAction.actionOneTwo(action1, paramArray[i]);
                }
            }
            this.initWithTwoActions(prev, paramArray[last]);
        }
    }
    static actionOneTwo(actionOne, actionTwo) {
        let sequence = new SequenceAction();
        sequence.initWithTwoActions(actionOne, actionTwo);
        return sequence;
    }
    initWithTwoActions(actionOne, actionTwo) {
        if (!actionOne || !actionTwo) {
            return false;
        }
        let durationOne = actionOne.getDuration();
        let durationTwo = actionTwo.getDuration();
        let d = durationOne + durationTwo;
        this.initWithDuration(d);
        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;
        return true;
    }
    startWithTarget(target) {
        super.startWithTarget(target);
        this._split = this._actions[0].getDuration() / this._duration;
        this._last = -1;
    }
    stop() {
        if (this._last !== -1)
            this._actions[this._last].stop();
        super.stop();
    }
    update(dt) {
        let new_t = 0;
        let found = 0;
        let locSplit = this._split;
        let locActions = this._actions;
        let locLast = this._last;
        let actionFound;
        dt = this.computeEaseTime(dt);
        if (dt < locSplit) {
            // action[0]
            new_t = (locSplit !== 0) ? dt / locSplit : 1;
            if (found === 0 && locLast === 1 && this._reversed) {
                // Reverse mode ?
                // XXX: Bug. this case doesn't contemplate when _last==-1, found=0 and in "reverse mode"
                // since it will require a hack to know if an action is on reverse mode or not.
                // "step" should be overriden, and the "reverseMode" value propagated to inner Sequences.
                locActions[1].update(0);
                locActions[1].stop();
            }
        }
        else {
            // action[1]
            found = 1;
            new_t = (locSplit === 1) ? 1 : (dt - locSplit) / (1 - locSplit);
            if (locLast === -1) {
                // action[0] was skipped, execute it.
                locActions[0].startWithTarget(this.target);
                locActions[0].update(1);
                locActions[0].stop();
            }
            if (locLast === 0) {
                // switching to action 1. stop action 0.
                locActions[0].update(1);
                locActions[0].stop();
            }
        }
        actionFound = locActions[found];
        // Last action found and it is done.
        if (locLast === found && actionFound.isDone())
            return;
        // Last action not found
        if (locLast !== found)
            actionFound.startWithTarget(this.target);
        new_t = new_t * actionFound._timesForRepeat;
        actionFound.update(new_t > 1 ? new_t % 1 : new_t);
        this._last = found;
    }
    reverse() {
        let action = SequenceAction.actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this.cloneDecoration(action);
        this.reverseEaseList(action);
        action._reversed = true;
        return action;
    }
}
exports.default = SequenceAction;

},{"./IntervalAction":22}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// https://www.womenzhai.cn/behaviorTree3/index.html
const ResLoader_1 = require("../../util/ResLoader");
class BehaviorTree {
    constructor() {
        this.treeNames = {};
    }
    loadAction(name, properties) {
        return this.loadNode(name, properties, b3.Action);
    }
    loadCondition(name, properties) {
        return this.loadNode(name, properties, b3.Condition);
    }
    loadNode(name, properties, type) {
        let node = new b3.Class(type);
        let nodeProto = node.prototype;
        nodeProto.name = name;
        for (let prop in properties) {
            nodeProto[prop] = properties[prop];
        }
        this.treeNames[name] = node;
        return node;
    }
    init(configPath) {
        ResLoader_1.default.getResSafe(configPath, this, this.createTree);
    }
    createTree(jsonData) {
        this.tree = new b3.BehaviorTree();
        this.tree.load(jsonData, this.treeNames);
    }
}
exports.default = BehaviorTree;

},{"../../util/ResLoader":41}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectionMethod = void 0;
const LCGRandom_1 = require("../math/LCGRandom");
const ISMath_1 = require("../math/ISMath");
var SelectionMethod;
(function (SelectionMethod) {
    SelectionMethod["Competitive"] = "Competitive";
    SelectionMethod["Natural"] = "Natural";
    SelectionMethod["Random_ForFun"] = "Random_ForFun";
})(SelectionMethod = exports.SelectionMethod || (exports.SelectionMethod = {}));
class GeneticOptimisation {
    constructor(populationCount, mutateProbability, selectionMethod) {
        this.selectionMethod = selectionMethod;
        this.populationCount = populationCount;
        this.mutateProbability = mutateProbability;
        this.population = [];
    }
    GetRandomGen(probs) {
        switch (this.selectionMethod) {
            case SelectionMethod.Competitive:
                let dis = 1.0 - Math.abs(ISMath_1.default.GaussianRandomDistributed() - 0.5);
                return Math.round(dis * (probs.length - 1));
            case SelectionMethod.Natural:
                let top = 0;
                let randomValue = GeneticOptimisation.rnd.lcgRandom();
                for (let i = 0; i < probs.length; i++) {
                    let bot = top;
                    top += probs[i];
                    if (randomValue >= bot && randomValue <= top)
                        return i;
                }
                return 0;
            case SelectionMethod.Random_ForFun:
                return GeneticOptimisation.rnd.lcgRandom(0, probs.length);
            default:
                // ArgumentOutOfRangeException
                console.error("ArgumentOutOfRangeException");
        }
    }
    GetPairs() {
        let res = [];
        let sum = 0;
        for (let i = 0; i < this.population.length; i++) {
            sum += this.population[i].fitness;
        }
        let lifeProb = [];
        for (let i = 0; i < this.populationCount; i++) {
            lifeProb[i] = this.population[i].fitness / sum;
        }
        lifeProb.sort((x, y) => y - x);
        let counter = 0;
        let testLimit = 0;
        while (counter < this.populationCount) {
            testLimit += 1;
            let leftGen = this.GetRandomGen(lifeProb);
            let rightGen = this.GetRandomGen(lifeProb);
            if (testLimit < 20) {
                if (leftGen == rightGen)
                    continue;
            }
            res.push(this.population[leftGen].Reproduce());
            res.push(this.population[rightGen].Reproduce());
            counter += 1;
        }
        return res;
    }
    ReproduceAll(pairs) {
        this.population.length = 0;
        for (let i = 0; i < pairs.length; i += 2) {
            this.Crossover(pairs[i], pairs[i + 1]);
            this.Mutate(pairs[i]);
            this.population.push(pairs[i]);
        }
    }
    CreateRandomPopulation(randGen) {
        this.population.length = 0;
        for (let i = 0; i < this.populationCount; i++) {
            this.population.push(randGen());
        }
    }
    Evolve(newFitnesses) {
        for (let i = 0; i < newFitnesses.length; i++) {
            this.population[i].fitness = newFitnesses[i];
        }
        this.ReproduceAll(this.GetPairs());
    }
    Mutate(gen) {
        let w = gen.optimizeableValues;
        for (let i = 0; i < w.length; i++)
            if (GeneticOptimisation.rnd.lcgRandom() < this.mutateProbability) {
                w[i] += GeneticOptimisation.rnd.lcgRandom() * 2 - 1;
            }
        gen.optimizeableValues = w;
    }
    Crossover(mom, dad) {
        let momW = mom.optimizeableValues;
        let dadW = dad.optimizeableValues;
        let n = GeneticOptimisation.rnd.lcgRandom(0, momW.length);
        for (let i = 0; i < momW.length; i++) {
            if (i < n)
                momW[i] = dadW[i];
            else
                dadW[i] = momW[i];
        }
        mom.optimizeableValues = momW;
        dad.optimizeableValues = dadW;
    }
    RandomizePopulation(min = -1.0, max = 1.0) {
        for (let i = 0; i < this.populationCount; i++) {
            GeneticOptimisation.Randomize(this.population[i], min, max);
        }
    }
    static Randomize(gen, min, max) {
        let w = gen.optimizeableValues;
        for (let i = 0; i < w.length; i++) {
            w[i] = GeneticOptimisation.rnd.lcgRandom() * (max - min) + min;
        }
        gen.optimizeableValues = w;
    }
}
exports.default = GeneticOptimisation;
GeneticOptimisation.rnd = new LCGRandom_1.default(Date.now());

},{"../math/ISMath":30,"../math/LCGRandom":31}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NeuralNetwork_1 = require("../neuralnetwork/NeuralNetwork");
class GeneticOptimizeableNerualNetwork extends NeuralNetwork_1.default {
    constructor(topology) {
        super(topology);
    }
    get optimizeableValues() {
        return this.Serialize();
    }
    set optimizeableValues(value) {
        this.Deserialize(value);
    }
    Reproduce() {
        let clone = new GeneticOptimizeableNerualNetwork(this.layers);
        clone.Deserialize(this.Serialize());
        for (let i = 0; i < this.layers.length; i++) {
            for (let j = 0; j < this.layers[i]; j++) {
                clone.neuronsOutputs[i][j] = this.neuronsOutputs[i][j];
            }
        }
        for (let i = 0; i < this.layers.length - 1; i++) {
            for (let j = 0; j < this.layers[i + 1]; j++) {
                clone.activateFunctions[i][j] = this.activateFunctions[i][j];
            }
        }
        clone.fitness = this.fitness;
        return clone;
    }
}
exports.default = GeneticOptimizeableNerualNetwork;

},{"../neuralnetwork/NeuralNetwork":33}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ISGaussianDistributionInfo = void 0;
const LCGRandom_1 = require("./LCGRandom");
class ISGaussianDistributionInfo {
}
exports.ISGaussianDistributionInfo = ISGaussianDistributionInfo;
class ISMath {
    static GaussianRandomDistributed() {
        let u1 = ISMath.Random.lcgRandom();
        let u2 = ISMath.Random.lcgRandom();
        let randStdNormal = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2);
        return randStdNormal / 12.5663706144 + 0.5;
    }
    static GaussianDistribution1(info, x) {
        return ISMath.GaussianDistribution3(x, info.s, info.o, info.u);
    }
    static GaussianDistribution2(info, x, y) {
        return ISMath.GaussianDistribution1(info, x) * ISMath.GaussianDistribution1(info, y) / 2;
    }
    static GaussianDistribution3(x, s, o, u) {
        let sqro = o * o;
        return 1 / Math.sqrt(6.283185307 * sqro) * Math.exp(-(Math.pow(s * x - s * u, 2) / (2 * sqro)));
    }
    static GaussianDistribution(x, s, o, u) {
        if (x != null && s != null && o != null && u != null) {
            ISMath.GaussianDistribution3(x, s, o, u);
        }
        else if (x != null && s != null && o != null) {
            ISMath.GaussianDistribution2(x, s, o);
        }
    }
    static ContainsIn(value, a, b) {
        return value >= a && value <= b;
    }
    static RotateVector(v, angle) {
        return new Laya.Vector2(v.x * Math.cos(angle) - v.y * Math.sin(angle), v.x * Math.sin(angle) + v.y * Math.cos(angle));
    }
    static RotateVectorXZ(v, angle) {
        return new Laya.Vector3(v.x * Math.cos(angle) - v.z * Math.sin(angle), 0, v.x * Math.sin(angle) + v.z * Math.cos(angle));
    }
}
exports.default = ISMath;
ISMath.Random = new LCGRandom_1.default(Date.now());

},{"./LCGRandom":31}],31:[function(require,module,exports){
"use strict";
/**
 * 线性同余随机发生器
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * I n+1=aI n+c(mod m)生成的伪随机数序列最大周期m，范围在0到m-1之间.Hull-Dobell定理:
 * 1.c与m互质
 * 2.a - 1可以被m的所有质因数整除
 * 3.如果m是4的倍数，a - 1也必须是4的倍数
 * a=9301, c = 49297, m = 233280这组参数满足
 */
class LCGRandom {
    constructor(seed) {
        this.lcgRandomSeed = 1;
        this.setLcgSeed(seed);
    }
    setLcgSeed(seed) {
        this.lcgRandomSeed = seed;
    }
    lcgRandom(min = 0, max = 1) {
        min = min;
        max = max;
        this.lcgRandomSeed = (this.lcgRandomSeed * 9301 + 49297) % 233280;
        const rnd = this.lcgRandomSeed / 233280.0;
        return min + rnd * (max - min);
    }
    lcgRandomInt(min = 0, max = 1) {
        min = min;
        max = max;
        this.lcgRandomSeed = (this.lcgRandomSeed * 9301 + 49297) % 233280;
        const rnd = this.lcgRandomSeed / 233280.0;
        return min + Math.floor(rnd * (max - min + 1));
    }
}
exports.default = LCGRandom;

},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TanhFunction = exports.SigmoidFunction = void 0;
class ThersholdFunction {
    Compute(x) {
        return x > 0.0 ? 1.0 : -1.0;
    }
}
exports.default = ThersholdFunction;
class SigmoidFunction {
    Compute(x) {
        return 1.0 / (1.0 + Math.exp(-x));
    }
}
exports.SigmoidFunction = SigmoidFunction;
class TanhFunction {
    Compute(x) {
        return Math.tanh(x);
    }
}
exports.TanhFunction = TanhFunction;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActivationFunction_1 = require("./ActivationFunction");
class NeuralNetwork {
    constructor(layers) {
        let layersLength = layers.length;
        this.layers = layers;
        this.neuronsOutputs = [];
        this.activateFunctions = [];
        this.weights = [];
        this.bias = [];
        for (let i = 0; i < layersLength; i++) {
            this.neuronsOutputs[i] = [];
            for (let k = 0; k < this.layers[i]; k++) {
                this.neuronsOutputs[i].push(0);
            }
        }
        let func = new ActivationFunction_1.SigmoidFunction();
        for (let i = 0; i < layersLength - 1; i++) {
            this.weights[i] = [];
            this.activateFunctions[i] = [];
            for (let j = 0; j < this.layers[i]; j++) {
                this.weights[i][j] = [];
                for (let k = 0; k < this.layers[i + 1]; k++) {
                    this.weights[i][j].push(0);
                }
            }
            for (let j = 0; j < this.layers[i + 1]; j++) {
                this.activateFunctions[i][j] = func;
            }
            this.bias[i] = [];
            for (let k = 0; k < this.layers[i + 1]; k++) {
                this.bias[i].push(0);
            }
        }
    }
    SetActivateFunction(func) {
        for (let i = 0; i < this.layers.length - 1; i++) {
            for (let j = 0; j < this.layers[i + 1]; j++) {
                this.activateFunctions[i][j] = func;
            }
        }
    }
    SetActivationFunctionForLayer(layerNum, func) {
        for (let j = 0; j < this.layers[layerNum + 1]; j++) {
            this.activateFunctions[layerNum][j] = func;
        }
    }
    Compute(input) {
        let res = [];
        for (let i = 0; i < this.layers[0]; i++) {
            this.neuronsOutputs[0][i] = input[i];
        }
        for (let i = 1; i < this.layers.length; i++) {
            for (let j = 0; j < this.layers[i]; j++) {
                let beforeActivation = 0;
                for (let k = 0; k < this.layers[i - 1]; k++) {
                    if (this.weights[i - 1][k][j] == null) {
                        this.weights[i - 1][k][j] = 0;
                    }
                    beforeActivation += this.neuronsOutputs[i - 1][k] * this.weights[i - 1][k][j];
                }
                if (this.bias[i - 1][j] == null) {
                    this.bias[i - 1][j] = 0;
                }
                beforeActivation += this.bias[i - 1][j];
                this.neuronsOutputs[i][j] = this.activateFunctions[i - 1][j].Compute(beforeActivation);
            }
        }
        res = this.neuronsOutputs[this.layers.length - 1];
        return res;
    }
    Serialize() {
        let res = [];
        for (let i = 0; i < this.layers.length - 1; i++) {
            res = res.concat(this.bias[i]);
        }
        for (let i = 0; i < this.layers.length - 1; i++) {
            for (let j = 0; j < this.layers[i]; j++) {
                res = res.concat(this.weights[i][j]);
            }
        }
        return res;
    }
    Deserialize(data) {
        let id = 0;
        for (let i = 0; i < this.layers.length - 1; i++) {
            for (let j = 0; j < this.layers[i + 1]; j++) {
                this.bias[i][j] = data[id];
                id++;
            }
        }
        for (let i = 0; i < this.layers.length - 1; i++) {
            for (let j = 0; j < this.layers[i]; j++) {
                for (let k = 0; k < this.layers[i + 1]; k++) {
                    this.weights[i][j][k] = data[id];
                    id++;
                }
            }
        }
    }
    Copy() {
        let clone = new NeuralNetwork(this.layers);
        clone.Deserialize(this.Serialize());
        for (let i = 0; i < this.layers.length; i++) {
            for (let j = 0; j < this.layers[i]; j++) {
                clone.neuronsOutputs[i][j] = this.neuronsOutputs[i][j];
            }
        }
        for (let i = 0; i < this.layers.length - 1; i++) {
            for (let j = 0; j < this.layers[i + 1]; j++) {
                clone.activateFunctions[i][j] = this.activateFunctions[i][j];
            }
        }
        return clone;
    }
}
exports.default = NeuralNetwork;

},{"./ActivationFunction":32}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CameraMoveScript extends Laya.Script3D {
    constructor() {
        super();
        /** @private */
        this._tempVector3 = new Laya.Vector3();
        this.yawPitchRoll = new Laya.Vector3();
        this.resultRotation = new Laya.Quaternion();
        this.tempRotationZ = new Laya.Quaternion();
        this.tempRotationX = new Laya.Quaternion();
        this.tempRotationY = new Laya.Quaternion();
        this.rotaionSpeed = 0.00006;
    }
    /**
     * @private
     */
    _updateRotation() {
        if (Math.abs(this.yawPitchRoll.y) < 1.50) {
            Laya.Quaternion.createFromYawPitchRoll(this.yawPitchRoll.x, this.yawPitchRoll.y, this.yawPitchRoll.z, this.tempRotationZ);
            this.tempRotationZ.cloneTo(this.camera.transform.localRotation);
            this.camera.transform.localRotation = this.camera.transform.localRotation;
        }
    }
    /**
     * @inheritDoc
     */
    onAwake() {
        Laya.stage.on(Laya.Event.RIGHT_MOUSE_DOWN, this, this.mouseDown);
        Laya.stage.on(Laya.Event.RIGHT_MOUSE_UP, this, this.mouseUp);
        //Laya.stage.on(Event.RIGHT_MOUSE_OUT, this, mouseOut);
        this.camera = this.owner;
    }
    /**
     * @inheritDoc
     */
    onUpdate() {
        let elapsedTime = Laya.timer.delta;
        if (!isNaN(this.lastMouseX) && !isNaN(this.lastMouseY) && this.isMouseDown) {
            let scene = this.owner.scene;
            Laya.KeyBoardManager.hasKeyDown(87) && this.moveForward(-0.01 * elapsedTime); //W
            Laya.KeyBoardManager.hasKeyDown(83) && this.moveForward(0.01 * elapsedTime); //S
            Laya.KeyBoardManager.hasKeyDown(65) && this.moveRight(-0.01 * elapsedTime); //A
            Laya.KeyBoardManager.hasKeyDown(68) && this.moveRight(0.01 * elapsedTime); //D
            Laya.KeyBoardManager.hasKeyDown(81) && this.moveVertical(0.01 * elapsedTime); //Q
            Laya.KeyBoardManager.hasKeyDown(69) && this.moveVertical(-0.01 * elapsedTime); //E
            let offsetX = Laya.stage.mouseX - this.lastMouseX;
            let offsetY = Laya.stage.mouseY - this.lastMouseY;
            let yprElem = this.yawPitchRoll;
            yprElem.x -= offsetX * this.rotaionSpeed * elapsedTime;
            yprElem.y -= offsetY * this.rotaionSpeed * elapsedTime;
            this._updateRotation();
        }
        this.lastMouseX = Laya.stage.mouseX;
        this.lastMouseY = Laya.stage.mouseY;
    }
    /**
     * @inheritDoc
     */
    onDestroy() {
        Laya.stage.off(Laya.Event.RIGHT_MOUSE_DOWN, this, this.mouseDown);
        Laya.stage.off(Laya.Event.RIGHT_MOUSE_UP, this, this.mouseUp);
    }
    mouseDown(e) {
        this.camera.transform.localRotation.getYawPitchRoll(this.yawPitchRoll);
        this.lastMouseX = Laya.stage.mouseX;
        this.lastMouseY = Laya.stage.mouseY;
        this.isMouseDown = true;
    }
    mouseUp(e) {
        this.isMouseDown = false;
    }
    mouseOut(e) {
        this.isMouseDown = false;
    }
    /**
     * 向前移动。
     * @param distance 移动距离。
     */
    moveForward(distance) {
        this._tempVector3.x = this._tempVector3.y = 0;
        this._tempVector3.z = distance;
        this.camera.transform.translate(this._tempVector3);
    }
    /**
     * 向右移动。
     * @param distance 移动距离。
     */
    moveRight(distance) {
        this._tempVector3.y = this._tempVector3.z = 0;
        this._tempVector3.x = distance;
        this.camera.transform.translate(this._tempVector3);
    }
    /**
     * 向上移动。
     * @param distance 移动距离。
     */
    moveVertical(distance) {
        this._tempVector3.x = this._tempVector3.z = 0;
        this._tempVector3.y = distance;
        this.camera.transform.translate(this._tempVector3, false);
    }
}
exports.default = CameraMoveScript;

},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityType = void 0;
var EntityType;
(function (EntityType) {
    EntityType["BaseEntity"] = "BaseEntity";
    EntityType["Bullet"] = "Bullet";
    EntityType["Monster"] = "Monster";
    EntityType["Player"] = "Player";
})(EntityType = exports.EntityType || (exports.EntityType = {}));

},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameRate = void 0;
/**游戏帧率 */
exports.FrameRate = 60;

},{}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.i18n = void 0;
function i18n(str) {
    return str;
}
exports.i18n = i18n;

},{}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNewUuid = exports.globalId = void 0;
exports.globalId = Math.floor(Math.random() * 516);
function getNewUuid() {
    return ++exports.globalId;
}
exports.getNewUuid = getNewUuid;

},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logTime = exports.error = exports.warn = exports.log = exports.logState = void 0;
exports.logState = true;
function log(content, ...subst) {
    if (exports.logState) {
        console.log(content, ...subst);
    }
}
exports.log = log;
function warn(content, ...subst) {
    if (exports.logState) {
        console.warn(content, ...subst);
    }
}
exports.warn = warn;
function error(content, ...subst) {
    if (exports.logState) {
        console.error(content, ...subst);
    }
}
exports.error = error;
function logTime(name, finish) {
    if (exports.logState) {
        if (finish) {
            console.timeEnd(name);
        }
        else {
            console.time(name);
        }
    }
}
exports.logTime = logTime;

},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get2VectorAngle = exports.getAngleByVector = exports.changeAngle = exports.getRandomArray = exports.getRandom = exports.angle2rad = void 0;
/**
 * 角度转弧度
 */
function angle2rad(angle) {
    return angle * 0.017453293;
}
exports.angle2rad = angle2rad;
/**
 * 获取x至y之前的1个随机数
 */
function getRandom(x, y) {
    return Math.floor(x + Math.random() * (y - x + 1));
}
exports.getRandom = getRandom;
/**
 * 获取x至之间的n个不重复随机数
 */
function getRandomArray(x, y, n) {
    const totalArray = [];
    for (let i = x; i <= y; i++) {
        totalArray.push(i);
    }
    const resultArray = [];
    const needCount = totalArray.length >= n ? n : totalArray.length;
    for (let j = 0; j <= needCount - 1; j++) {
        const index = Math.floor(Math.random() * totalArray.length);
        resultArray.push(totalArray[index]);
        totalArray.splice(index, 1);
    }
    return resultArray;
}
exports.getRandomArray = getRandomArray;
/**
 * 欧拉角(弧度制)转四元数
 */
function changeAngle(pitch, yaw, roll) {
    // tslint:disable-next-line:one-variable-per-declaration
    let cosRoll, sinRoll, cosPitch, sinPitch, cosyaw, sinyaw, qw, qx, qy, qz;
    cosRoll = Math.cos(roll * 0.5); // z 
    sinRoll = Math.sin(roll * 0.5); // z
    cosyaw = Math.cos(yaw * 0.5); // y
    sinyaw = Math.sin(yaw * 0.5); // y
    cosPitch = Math.cos(pitch * 0.5); // x
    sinPitch = Math.sin(pitch * 0.5); // x
    qx = cosRoll * sinyaw * cosPitch + sinRoll * cosyaw * sinPitch;
    qy = cosRoll * cosyaw * sinPitch - sinRoll * sinyaw * cosPitch;
    qz = sinRoll * cosyaw * cosPitch - cosRoll * sinyaw * sinPitch;
    qw = cosRoll * cosyaw * cosPitch + sinRoll * sinyaw * sinPitch;
    return { qx, qy, qz, qw };
}
exports.changeAngle = changeAngle;
/**
 * 输入一个向量,返回一个角度
 */
function getAngleByVector(x, y) {
    if (y === 0) {
        if (x < 0) {
            return 270;
        }
        else if (x >= 0) {
            return 90;
        }
    }
    if (x === 0) {
        if (y >= 0) {
            return 0;
        }
        else {
            return 180;
        }
    }
    let tanyx = Math.abs(y) / Math.abs(x);
    let angle = 0;
    if (y > 0 && x < 0) {
        angle = 270 + Math.atan(tanyx) * 180 / Math.PI;
    }
    else if (y > 0 && x > 0) {
        angle = 90 - Math.atan(tanyx) * 180 / Math.PI;
    }
    else if (y < 0 && x < 0) {
        angle = 270 - Math.atan(tanyx) * 180 / Math.PI;
    }
    else if (y < 0 && x > 0) {
        angle = 90 + Math.atan(tanyx) * 180 / Math.PI;
    }
    return angle;
}
exports.getAngleByVector = getAngleByVector;
/**
 * 两个二维向量余弦值计算
 */
function get2VectorAngle(vec1, vec2) {
    let molecular = vec1.x * vec2.x + vec1.y * vec2.y;
    let denominator = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y) * Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
    if (denominator != 0) {
        return molecular / denominator;
    }
    else {
        return 0;
    }
}
exports.get2VectorAngle = get2VectorAngle;

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("./Logger");
class ResLoader {
    static get Ins() {
        if (!ResLoader._resLoader) {
            ResLoader._resLoader = new ResLoader();
        }
        return ResLoader._resLoader;
    }
    static clearRes(urls) {
        for (let i = 0; i < urls.length; i++) {
            let res = Laya.loader.getRes(urls[i]);
            if (res instanceof Laya.Sprite3D) {
                res.transform && res.destroy(true);
            }
            Laya.loader.clearRes(urls[i]);
        }
    }
    static getRes(url) {
        let res = Laya.loader.getRes(url);
        if (res) {
            return res;
        }
        else {
            Logger_1.error("getRes fails: " + url);
            return null;
        }
    }
    static getResSafe(url, context = null, complete = null) {
        let res = Laya.loader.getRes(url);
        if (res) {
            complete.apply(context, [res]);
        }
        else {
            ResLoader.load([url], this, () => {
                let res = Laya.loader.getRes(url);
                complete.apply(context, [res]);
            });
        }
    }
    static loadRes(url, context = null, complete = null) {
        ResLoader.load([url], context, complete);
    }
    static load(urls, context = null, complete = null, progress = null) {
        let infoUrls = [];
        for (let i = 0; i < urls.length; i++) {
            let url = urls[i];
            let type = Laya.Loader.getTypeFromUrl(url);
            if (!type) {
                let ext = Laya.Utils.getFileExtension(url);
                switch (ext) {
                    case "lh":
                    case "ls":
                        type = Laya.Loader.HIERARCHY;
                        break;
                    case "lm":
                        type = Laya.Loader.MESH;
                        break;
                    case "lmat":
                        type = Laya.Loader.MATERIAL;
                        break;
                    case "ltc":
                        type = Laya.Loader.TEXTURECUBE;
                        break;
                    case "bmp":
                    case "gif":
                    case "dds":
                    case "ktx":
                    case "pvr":
                        type = Laya.Loader.TEXTURE2D;
                        break;
                    case "lani":
                        type = Laya.Loader.ANIMATIONCLIP;
                        break;
                    case "lav":
                        type = Laya.Loader.AVATAR;
                        break;
                    case "thdata":
                        type = Laya.Loader.TERRAINHEIGHTDATA;
                        break;
                    default:
                        type = Laya.Loader.BUFFER;
                        break;
                }
            }
            infoUrls.push({ url, type });
        }
        if (infoUrls.length <= 0) {
            return;
        }
        let completeHandler = null;
        let progressHandler = null;
        if (context) {
            if (complete) {
                completeHandler = Laya.Handler.create(context, complete);
            }
            if (progress) {
                progressHandler = Laya.Handler.create(context, progress);
            }
        }
        Laya.loader.create(infoUrls, completeHandler, progressHandler);
    }
}
exports.default = ResLoader;

},{"./Logger":39}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTopPadding = exports.getSprite3DRenderer = void 0;
/**
 * 获取渲染器
 */
function getSprite3DRenderer(sprite) {
    let target;
    for (let i = 0, len = sprite.numChildren; i < len; i++) {
        let item = sprite.getChildAt(i);
        if (item instanceof Laya.MeshSprite3D) {
            target = item.meshRenderer;
            if (target) {
                break;
            }
        }
        else if (item instanceof Laya.SkinnedMeshSprite3D) {
            target = item.skinnedMeshRenderer;
            if (target) {
                break;
            }
        }
        else if (item) {
            target = getSprite3DRenderer(item);
        }
    }
    return target;
}
exports.getSprite3DRenderer = getSprite3DRenderer;
// 上边距
function getTopPadding() {
    if (Laya.Browser.onWeiXin) {
        let height = Laya.Browser.clientWidth * 16 / 9;
        return Math.abs(Laya.Browser.clientHeight - height) * 0.5;
    }
    else {
        return 0;
    }
}
exports.getTopPadding = getTopPadding;

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerController_1 = require("./controller/PlayerController");
const SkillController_1 = require("./controller/SkillController");
const BulletController_1 = require("./controller/BulletController");
const GameStageController_1 = require("./controller/GameStageController");
const MonsterController_1 = require("./controller/MonsterController");
const AIGeneticController_1 = require("./controller/AIGeneticController");
const AIBehaviorController_1 = require("./controller/AIBehaviorController");
class GameManager {
    static get Ins() {
        if (!GameManager._gameManager) {
            GameManager._gameManager = new GameManager();
        }
        return GameManager._gameManager;
    }
    static init() {
        GameManager.Ins.clear();
        GameManager.Ins.playerController = new PlayerController_1.default();
        GameManager.Ins.playerController.onLoad();
        GameManager.Ins.skillController = new SkillController_1.default();
        GameManager.Ins.skillController.onLoad();
        GameManager.Ins.bulletController = new BulletController_1.default();
        GameManager.Ins.bulletController.onLoad();
        GameManager.Ins.gameStageController = new GameStageController_1.default();
        GameManager.Ins.gameStageController.onLoad();
        GameManager.Ins.monsterController = new MonsterController_1.default();
        GameManager.Ins.monsterController.onLoad();
        GameManager.Ins.aiGeneticController = new AIGeneticController_1.default();
        GameManager.Ins.aiGeneticController.onLoad();
        GameManager.Ins.aiBehaviorController = new AIBehaviorController_1.default();
        GameManager.Ins.aiBehaviorController.onLoad();
    }
    static get PlayerController() {
        return GameManager.Ins.playerController;
    }
    static get AIGeneticController() {
        return GameManager.Ins.aiGeneticController;
    }
    static get AIBehaviorController() {
        return GameManager.Ins.aiBehaviorController;
    }
    static get SkillController() {
        return GameManager.Ins.skillController;
    }
    static get BulletController() {
        return GameManager.Ins.bulletController;
    }
    static get GameStageController() {
        return GameManager.Ins.gameStageController;
    }
    static get MonsterController() {
        return GameManager.Ins.monsterController;
    }
    end() {
    }
    static start() {
        GameManager.Ins.gameStageController.start();
    }
    clear() {
        this.playerController && this.playerController.onDestory();
        this.playerController = null;
        this.skillController && this.skillController.onDestory();
        this.skillController = null;
        this.bulletController && this.bulletController.onDestory();
        this.bulletController = null;
        this.gameStageController && this.gameStageController.onDestory();
        this.gameStageController = null;
        this.monsterController && this.monsterController.onDestory();
        this.monsterController = null;
    }
}
exports.default = GameManager;

},{"./controller/AIBehaviorController":66,"./controller/AIGeneticController":67,"./controller/BulletController":68,"./controller/GameStageController":69,"./controller/MonsterController":70,"./controller/PlayerController":71,"./controller/SkillController":72}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const layaMaxUI_1 = require("./../ui/layaMaxUI");
const ResLoader_1 = require("../core/util/ResLoader");
const UI_Loading_1 = require("../ui/Common/UI_Loading");
/**
 * 本示例采用非脚本的方式实现，而使用继承页面基类，实现页面逻辑。在IDE里面设置场景的Runtime属性即可和场景进行关联
 * 相比脚本方式，继承式页面类，可以直接使用页面定义的属性（通过IDE内var属性定义），比如this.tipLbll，this.scoreLbl，具有代码提示效果
 * 建议：如果是页面级的逻辑，需要频繁访问页面内多个元素，使用继承式写法，如果是独立小模块，功能单一，建议用脚本方式实现，比如子弹脚本。
 */
class GameUI extends layaMaxUI_1.ui.test.TestSceneUI {
    constructor() {
        super();
        //添加3D场景
        var scene = Laya.stage.addChild(new Laya.Scene3D());
        //添加照相机
        var camera = (scene.addChild(new Laya.Camera(0, 0.1, 100)));
        camera.transform.translate(new Laya.Vector3(0, 3, 3));
        camera.transform.rotate(new Laya.Vector3(-30, 0, 0), true, false);
        //添加方向光
        var directionLight = scene.addChild(new Laya.DirectionLight());
        directionLight.color = new Laya.Vector3(0.6, 0.6, 0.6);
        directionLight.transform.worldMatrix.setForward(new Laya.Vector3(1, -1, 0));
        //添加自定义模型
        var box = scene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(1, 2, 1)));
        box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false);
        box.transform.translate(new Laya.Vector3(0, 3, 0));
        var material = new Laya.BlinnPhongMaterial();
        Laya.Texture2D.load("res/layabox.png", Laya.Handler.create(null, function (tex) {
            material.albedoTexture = tex;
        }));
        box.meshRenderer.material = material;
        box.addComponent(Laya.PhysicsCollider);
        let rigid = box.addComponent(Laya.Rigidbody3D);
        //有刚体的shape要加在刚体上
        rigid.colliderShape = new Laya.BoxColliderShape(1, 2, 1);
        //添加一个地板
        var floor = scene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(10, 10)));
        //给地板添加物理组件
        var floorCollicar = floor.addComponent(Laya.PhysicsCollider);
        // 添加collidershape
        floorCollicar.colliderShape = new Laya.BoxColliderShape(10, 0, 10);
        // return
        // Laya.loader.load([{ url: "res/gui/Common_atlas0.png", type: Laya.Loader.IMAGE },
        //     { url: "res/gui/Common.fui", type: Laya.Loader.BUFFER }
        // ], Laya.Handler.create(this, this.onLoaded));
        ResLoader_1.default.load([
            "res/gui/Common_atlas0.png",
            "res/gui/Common.fui"
        ], this, this.onLoaded);
    }
    onLoaded() {
        fgui.UIPackage.addPackage("res/gui/Common");
        let view = UI_Loading_1.default.createInstance();
        Laya.stage.addChild(view.displayObject);
    }
}
exports.default = GameUI;

},{"../core/util/ResLoader":41,"../ui/Common/UI_Loading":105,"./../ui/layaMaxUI":107}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonsterTreeTitle = void 0;
const BehaviorTree_1 = require("../../core/ai/behavior/BehaviorTree");
var MonsterTreeTitle;
(function (MonsterTreeTitle) {
    MonsterTreeTitle["attack"] = "attack";
    MonsterTreeTitle["idle"] = "idle";
    MonsterTreeTitle["patrol"] = "patrol";
    MonsterTreeTitle["dodge"] = "dodge";
    MonsterTreeTitle["flee"] = "flee";
    MonsterTreeTitle["turnDir"] = "turnDir";
    MonsterTreeTitle["lowLife"] = "lowLife";
    MonsterTreeTitle["attackDesire"] = "attackDesire";
    MonsterTreeTitle["watchBullet"] = "watchBullet";
    MonsterTreeTitle["onRange"] = "onRange";
    MonsterTreeTitle["wallCollision"] = "wallCollision";
})(MonsterTreeTitle = exports.MonsterTreeTitle || (exports.MonsterTreeTitle = {}));
class MonsterBehaviorTree extends BehaviorTree_1.default {
    constructor() {
        super();
    }
    init(configPath) {
        this.treeNames = {};
        this.tree = null;
        this.initAction();
        this.initConditions();
        super.init(configPath);
    }
    initAction() {
        this.loadAction(MonsterTreeTitle.attack, {
            tick: function (tick) {
                let target = tick.target;
                target.attack();
                return b3.SUCCESS;
            }
        });
        this.loadAction(MonsterTreeTitle.idle, {
            tick: function (tick) {
                return b3.SUCCESS;
            }
        });
        this.loadAction(MonsterTreeTitle.patrol, {
            tick: function (tick) {
                let target = tick.target;
                target.patrol();
                return b3.SUCCESS;
            }
        });
        this.loadAction(MonsterTreeTitle.flee, {
            tick: function (tick) {
                let target = tick.target;
                target.flee();
                return b3.SUCCESS;
            }
        });
        this.loadAction(MonsterTreeTitle.dodge, {
            tick: function (tick) {
                let target = tick.target;
                target.dodge();
                return b3.SUCCESS;
            }
        });
        this.loadAction(MonsterTreeTitle.turnDir, {
            tick: function (tick) {
                let target = tick.target;
                target.turnDir();
                return b3.SUCCESS;
            }
        });
    }
    initConditions() {
        this.loadCondition(MonsterTreeTitle.watchBullet, {
            tick: function (tick) {
                let target = tick.target;
                if (target.watchBullet()) {
                    return b3.SUCCESS;
                }
                else {
                    return b3.FAILURE;
                }
            }
        });
        this.loadCondition(MonsterTreeTitle.onRange, {
            tick: function (tick) {
                let target = tick.target;
                if (target.isOnRange()) {
                    return b3.SUCCESS;
                }
                else {
                    return b3.FAILURE;
                }
            }
        });
        this.loadCondition(MonsterTreeTitle.lowLife, {
            tick: function (tick) {
                let target = tick.target;
                if (target.lowLife()) {
                    return b3.SUCCESS;
                }
                else {
                    return b3.FAILURE;
                }
            }
        });
        this.loadCondition(MonsterTreeTitle.attackDesire, {
            tick: function (tick) {
                let target = tick.target;
                if (target.attackDesire()) {
                    return b3.SUCCESS;
                }
                else {
                    return b3.FAILURE;
                }
            }
        });
        this.loadAction(MonsterTreeTitle.wallCollision, {
            tick: function (tick) {
                let target = tick.target;
                if (target.wallCollision()) {
                    return b3.SUCCESS;
                }
                else {
                    return b3.FAILURE;
                }
            }
        });
    }
}
exports.default = MonsterBehaviorTree;

},{"../../core/ai/behavior/BehaviorTree":27}],46:[function(require,module,exports){
"use strict";
/**
 * 游戏缓存数据
 */
Object.defineProperty(exports, "__esModule", { value: true });
class GameCacheData {
    constructor() {
        this.curChapterIndex = 1;
        this.evolutionCycle = 2000;
    }
    static get Ins() {
        if (!GameCacheData._gameCacheData) {
            GameCacheData._gameCacheData = new GameCacheData();
        }
        return GameCacheData._gameCacheData;
    }
    get evolutionCount() {
        return this._evolutionCount;
    }
    set evolutionCount(value) {
        this._evolutionCount = value;
    }
}
exports.default = GameCacheData;

},{}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CameraMoveScript_1 = require("../../core/util/CameraMoveScript");
class GameCamera extends Laya.Sprite3D {
    constructor() {
        super();
        this.pVector = new Laya.Vector3(0, 0, 1);
        this.init();
    }
    init() {
        this.camera = new Laya.Camera(0, 0.1, 100);
        this.addChild(this.camera);
        this.camera.transform.translate(new Laya.Vector3(0.27, 8.84, 8.9));
        this.camera.transform.rotate(new Laya.Vector3(-39.68, 0, 1), true, false);
        // this.camera.transform.translate(new Laya.Vector3(0,10,0), false);
        this.camera.addComponent(CameraMoveScript_1.default);
    }
    worldToViewportPoint(v3) {
        let transPos = new Laya.Vector4(0, 0, 0, 0);
        let renderTarget = this.camera.renderTarget;
        this.camera.renderTarget = null;
        this.camera.worldToViewportPoint(v3, transPos);
        this.camera.renderTarget = renderTarget;
        return new Laya.Vector2(transPos.x, transPos.y);
    }
    translate(pos) {
        this.camera.transform.translate(pos, false);
    }
    lookAt(pos) {
        this.camera.transform.lookAt(pos, this.pVector);
    }
    getDistance(pos) {
        let camPos = this.camera.transform.position;
        let dx = pos.x - camPos.x;
        let dz = pos.z - camPos.z;
        return Math.sqrt(dx * dx + dz * dz);
    }
}
exports.default = GameCamera;

},{"../../core/util/CameraMoveScript":34}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResLoader_1 = require("../../core/util/ResLoader");
const ChapterConfig_1 = require("../config/ChapterConfig");
const MonsterConfig_1 = require("../config/MonsterConfig");
const MonsterFacConfig_1 = require("../config/MonsterFacConfig");
/**
 * 游戏配置数据
 */
class GameConfigData {
    static get Ins() {
        if (!GameConfigData._gameConfigData) {
            GameConfigData._gameConfigData = new GameConfigData();
        }
        return GameConfigData._gameConfigData;
    }
    init() {
        ResLoader_1.default.load([
            MonsterConfig_1.MonsterConfig.resPath,
            MonsterFacConfig_1.MonsterFacConfig.resPath,
            ChapterConfig_1.ChapterConfig.resPath
        ], this, this.onLoad);
    }
    onLoad() {
        this.monsterConfig = MonsterConfig_1.MonsterConfig.deserialize();
        this.monsterFacConfig = MonsterFacConfig_1.MonsterFacConfig.deserialize();
        this.chapterConfigData = ChapterConfig_1.ChapterConfig.deserialize();
    }
    getChapterConfigData(index) {
        for (let i = 0; i < this.chapterConfigData.length; i++) {
            let data = this.chapterConfigData[i];
            if (index == data.index) {
                return data;
            }
        }
    }
    getMonsterFacConfigData(index) {
        let configData = [];
        for (let i = 0; i < this.monsterFacConfig.length; i++) {
            let data = this.monsterFacConfig[i];
            if (index == data.stage) {
                configData.push(data);
            }
        }
        return configData;
    }
    getMonsterConfigData(id) {
        for (let i = 0; i < this.monsterConfig.length; i++) {
            let data = this.monsterConfig[i];
            if (id == data.id) {
                return data;
            }
        }
    }
    getMonsterFacByWave(index, wave) {
        let configData = [];
        for (let i = 0; i < this.monsterFacConfig.length; i++) {
            let data = this.monsterFacConfig[i];
            if (index == data.stage && wave == data.wave) {
                configData.push(data);
            }
        }
        return configData;
    }
}
exports.default = GameConfigData;

},{"../../core/util/ResLoader":41,"../config/ChapterConfig":63,"../config/MonsterConfig":64,"../config/MonsterFacConfig":65}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectConfig = void 0;
const ResLoader_1 = require("../../core/util/ResLoader");
class ProjectConfig {
    get cdnUrl() {
        return this._cdnUrl;
    }
    static get Ins() {
        if (!ProjectConfig._configData) {
            ProjectConfig._configData = new ProjectConfig();
        }
        return ProjectConfig._configData;
    }
    init() {
        let json = ResLoader_1.default.getRes("config.json");
        let curEvn = json["curEvn"]["platform"];
        let curData = json["platforms"][curEvn];
        this._cdnUrl = curData["cdn"];
    }
}
exports.ProjectConfig = ProjectConfig;
ProjectConfig.resPath = "config.json";

},{"../../core/util/ResLoader":41}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulletCollisionComp = void 0;
const Logger_1 = require("../../core/util/Logger");
const BaseComponent_1 = require("../../core/BaseComponent");
const TriggerCollisionScript_1 = require("../../core/TriggerCollisionScript");
const BindEntityScript_1 = require("../../core/BindEntityScript");
const MonsterCollisionComp_1 = require("./MonsterCollisionComp");
class BulletCollisionComp extends BaseComponent_1.default {
    constructor() {
        super();
    }
    init(prefab) {
        this.bullet = this.entity;
        this.prefab = prefab;
        this.collisionScript = this.prefab.getChildAt(0).addComponent(TriggerCollisionScript_1.default);
        this.collisionScript.setCollisionEnter(this, this.onCollisionEnter);
        this.collisionScript.setTriggerEnter(this, this.onTriggerEnter);
    }
    onTriggerEnter(other) {
        MonsterCollisionComp_1.MonsterCollisionComp;
        let sprite = other.owner;
        if (sprite) {
            let bindEntityScript = sprite.getComponent(BindEntityScript_1.default);
            if (bindEntityScript) {
                if (this.bullet.curUserUuid == bindEntityScript.entity.uuid) {
                    // 不与使用者触发
                    return;
                }
            }
        }
        this.bullet.removeBullet();
    }
    onCollisionEnter(collision) {
        if (collision.other.owner.name == "block") {
            Logger_1.log("onCollisionStay");
        }
    }
    onDestory() {
        this.collisionScript && this.collisionScript.onDestroy();
        this.collisionScript = null;
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.BulletCollisionComp = BulletCollisionComp;

},{"../../core/BaseComponent":3,"../../core/BindEntityScript":10,"../../core/TriggerCollisionScript":14,"../../core/util/Logger":39,"./MonsterCollisionComp":54}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulletTrajectoryComp = void 0;
const BaseComponent_1 = require("../../core/BaseComponent");
class BulletTrajectoryComp extends BaseComponent_1.default {
    constructor() {
        super();
        this._count = 5;
        this.updateComp = true;
        this.trajectory = [];
    }
    update() {
        let point = this.entity.model.localPosition.clone();
        this.trajectory.unshift(point);
        this.trajectory.length = this._count;
    }
    /**
     * 弹道矢量
     */
    calcuVector() {
        if (this.trajectory[0] && this.trajectory[1]) {
            let x = this.trajectory[0].x - this.trajectory[1].x;
            let z = this.trajectory[0].z - this.trajectory[1].z;
            return new Laya.Vector2(x, z);
        }
        return false;
    }
    clearTrajectory() {
        this.trajectory.length = 0;
    }
    onDestory() {
        super.onDestory();
        this.clearTrajectory();
    }
}
exports.BulletTrajectoryComp = BulletTrajectoryComp;

},{"../../core/BaseComponent":3}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HpBarComp = void 0;
const BaseView_1 = require("../../core/BaseView");
const UI_HpBar_1 = require("../../ui/Battle/UI_HpBar");
const ViewManager_1 = require("../../core/ViewManager");
const SceneManager_1 = require("../../core/SceneManager");
const GameConfigData_1 = require("../common/GameConfigData");
class HpBarComp extends BaseView_1.default {
    constructor() {
        super();
        this._curHp = 1;
        this._maxHp = 1;
        // 血条偏移量
        this._devValue = 1.9;
        this._scale = 0.75;
        this._reduceDelTween = 0;
        this._reduceWidth = 0;
        this._hpTween = false;
        this.updateComp = true;
    }
    onLoad() {
        super.onLoad();
        this.view = UI_HpBar_1.default.createInstance();
        ViewManager_1.default.getUiPanel().addChild(this.view.displayObject);
        this.view.displayObject.scale(this._scale, this._scale);
        this.setName();
    }
    setValue(curHp, maxHp) {
        let preCurHp = this._curHp;
        let preMaxHp = this._maxHp;
        let prePercent = preCurHp / preMaxHp;
        this._curHp = curHp;
        this._maxHp = maxHp;
        let curPercent = curHp / maxHp;
        this.playHpAnimation(prePercent, curPercent);
        curPercent = curPercent <= 0 ? 0.01 : curPercent;
        this.setCurHpText(curHp);
    }
    playHpAnimation(preValue, curValue) {
        let maxWidth = this.view.width - 2;
        let beforeWidth = maxWidth * preValue;
        let toWidth = maxWidth * curValue;
        toWidth = toWidth <= 0 ? 0.01 : toWidth;
        if (preValue > curValue) {
            // 如果扣血,播放动画
            this.view.m_reduce.width = beforeWidth;
            this._reduceDelTween = (toWidth - beforeWidth) / 16;
            this._reduceWidth = toWidth;
            this._hpTween = true;
        }
        this.view.m_bar.width = toWidth;
    }
    update() {
        this.updateViewPos();
        if (this._hpTween) {
            if (this.view.m_reduce.width > this._reduceWidth) {
                this.view.m_reduce.width += this._reduceDelTween;
            }
            else {
                this.view.m_reduce.width = this._reduceWidth;
                this._hpTween = false;
            }
        }
    }
    updateViewPos() {
        let gameCamera = SceneManager_1.default.curSence.gameCamera;
        let entityPos = this.entity.prefab.transform.position;
        // let distance = gameCamera.getDistance(entityPos) - 8.9;
        // let scaleDel = -0.01 * distance + 1;
        // scaleDel = scaleDel > 1.2 ? 1.2: scaleDel
        // scaleDel = scaleDel < 0.8 ? 0.8: scaleDel
        // this.view.setScale(scaleDel, scaleDel);
        let devPos = new Laya.Vector3(entityPos.x, entityPos.y + this._devValue, entityPos.z);
        let transPos = gameCamera.worldToViewportPoint(devPos);
        this.view.setXY(transPos.x - this.view.width * this._scale / 2, transPos.y + this.view.height - 30);
    }
    setCurHpText(curHp) {
        let bloodNum = Math.floor(curHp);
        this.view.m_hpText.text = bloodNum + "";
    }
    setName() {
        let monsterData = GameConfigData_1.default.Ins.getMonsterConfigData(this.entity.model.id);
        if (monsterData) {
            this.view.m_name.text = monsterData.name;
        }
        else {
            this.view.m_name.text = "";
        }
    }
    onDestory() {
        ViewManager_1.default.getUiPanel().removeChild(this.view.displayObject);
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.HpBarComp = HpBarComp;

},{"../../core/BaseView":9,"../../core/SceneManager":13,"../../core/ViewManager":15,"../../ui/Battle/UI_HpBar":98,"../common/GameConfigData":48}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonsterAIComp = exports.MonsterAIEvent = void 0;
const BaseComponent_1 = require("../../core/BaseComponent");
const GeneticOptimizeableNerualNetwork_1 = require("../../core/ai/genetic/GeneticOptimizeableNerualNetwork");
const ActivationFunction_1 = require("../../core/ai/neuralnetwork/ActivationFunction");
const EventManager_1 = require("../../core/EventManager");
var MonsterAIEvent;
(function (MonsterAIEvent) {
    MonsterAIEvent["ThinkData"] = "ThinkData";
})(MonsterAIEvent = exports.MonsterAIEvent || (exports.MonsterAIEvent = {}));
class MonsterAIComp extends BaseComponent_1.default {
    constructor() {
        super();
        this.preOut1 = 0;
        this.preOut2 = 0;
        this.network = new GeneticOptimizeableNerualNetwork_1.default([7, 8, 4, 1]);
        let actvationFunction = new ActivationFunction_1.TanhFunction();
        for (var i = 0; i < this.network.activateFunctions.length; i++) {
            this.network.SetActivationFunctionForLayer(i, actvationFunction);
        }
    }
    addFitness(v) {
        this.entity.model.fitness += v;
    }
    get fitness() {
        return this.entity.model.fitness;
    }
    thinkDeeply() {
        let inputs = [];
        let attackTarget = this.entity.model.attackTarget;
        let enableAttack = this.entity.model.enableAttack();
        let curPos = this.entity.model.localPosition;
        let dodgeBullet = this.entity.dodgeBullet();
        let rayCast = this.entity.wallRayCastComp.rayCast();
        let ray = rayCast == true ? 1 : 0;
        this.entity.findTarget();
        if (rayCast) {
            this.addFitness(-1);
        }
        // 是否有攻击目标
        inputs[0] = attackTarget != null ? 0 : 1;
        // 当前血量
        inputs[1] = this.entity.model.curHp;
        // 子弹位置
        inputs[2] = dodgeBullet;
        // 射线检查
        inputs[3] = ray;
        // 当前位置
        inputs[4] = curPos.x;
        inputs[5] = curPos.z;
        // 是否可以攻击
        inputs[6] = enableAttack ? 0 : 1;
        inputs[7] = this.preOut1;
        // inputs[8] = this.preOut2;
        let output = this.network.Compute(inputs);
        this.preOut1 = output[0];
        //this.preOut2 = output[1];
        EventManager_1.default.emit(MonsterAIEvent.ThinkData, this.entity.model.sid, inputs, this.entity.model.fitness, this.entity.model.name);
        if (output[0] <= 0) {
            this.entity.roleDriverComp.stopCmd();
        }
        else {
            this.entity.roleDriverComp.moveCmd(output[0] * 360);
        }
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
    onDestory() {
        super.onDestory();
    }
}
exports.MonsterAIComp = MonsterAIComp;

},{"../../core/BaseComponent":3,"../../core/EventManager":11,"../../core/ai/genetic/GeneticOptimizeableNerualNetwork":29,"../../core/ai/neuralnetwork/ActivationFunction":32}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonsterCollisionComp = void 0;
const Logger_1 = require("../../core/util/Logger");
const BaseComponent_1 = require("../../core/BaseComponent");
const TriggerCollisionScript_1 = require("../../core/TriggerCollisionScript");
const BindEntityScript_1 = require("../../core/BindEntityScript");
const EntityTypeDefine_1 = require("../../core/util/EntityTypeDefine");
class MonsterCollisionComp extends BaseComponent_1.default {
    constructor() {
        super();
    }
    init(prefab) {
        this.monster = this.entity;
        this.prefab = prefab;
        this.collisionScript = this.prefab.addComponent(TriggerCollisionScript_1.default);
        this.collisionScript.setCollisionEnter(this, this.onCollisionEnter);
        this.collisionScript.setTriggerEnter(this, this.onTriggerEnter);
    }
    onCollisionEnter(collision) {
        if (collision.other.owner.name == "block") {
            Logger_1.log("onCollisionStay");
        }
    }
    onTriggerEnter(other) {
        let sprite = other.owner.parent;
        if (sprite) {
            let bindEntityScript = sprite.getComponent(BindEntityScript_1.default);
            if (bindEntityScript) {
                let entityType = bindEntityScript.entity.entityType;
                if (entityType == EntityTypeDefine_1.EntityType.Bullet) {
                    let bullet = bindEntityScript.entity;
                    if (bullet.curUserUuid != this.monster.uuid) {
                        if (bullet.curUser) {
                            bullet.curUser.onHit();
                        }
                        this.monster.onHurt(10);
                    }
                }
            }
        }
    }
    onDestory() {
        this.collisionScript && this.collisionScript.onDestroy();
        this.collisionScript = null;
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.MonsterCollisionComp = MonsterCollisionComp;

},{"../../core/BaseComponent":3,"../../core/BindEntityScript":10,"../../core/TriggerCollisionScript":14,"../../core/util/EntityTypeDefine":35,"../../core/util/Logger":39}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerCollisionComp = void 0;
const Logger_1 = require("../../core/util/Logger");
const BaseComponent_1 = require("../../core/BaseComponent");
const TriggerCollisionScript_1 = require("../../core/TriggerCollisionScript");
const BindEntityScript_1 = require("../../core/BindEntityScript");
const EntityTypeDefine_1 = require("../../core/util/EntityTypeDefine");
class PlayerCollisionComp extends BaseComponent_1.default {
    constructor() {
        super();
    }
    init(prefab) {
        this.player = this.entity;
        this.prefab = prefab;
        this.collisionScript = this.prefab.addComponent(TriggerCollisionScript_1.default);
        this.collisionScript.setCollisionEnter(this, this.onCollisionEnter);
        this.collisionScript.setTriggerEnter(this, this.onTriggerEnter);
    }
    onTriggerEnter(other) {
        let sprite = other.owner.parent;
        if (sprite) {
            let bindEntityScript = sprite.getComponent(BindEntityScript_1.default);
            if (bindEntityScript) {
                let entityType = bindEntityScript.entity.entityType;
                if (entityType == EntityTypeDefine_1.EntityType.Bullet) {
                    let bullet = bindEntityScript.entity;
                    if (bullet.curUserUuid != this.player.uuid) {
                        this.player.onHurt(10);
                    }
                }
            }
        }
    }
    onCollisionEnter(collision) {
        if (collision.other.owner.name == "block") {
            Logger_1.log("onCollisionStay");
        }
    }
    onDestory() {
        this.collisionScript && this.collisionScript.onDestroy();
        this.collisionScript = null;
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.PlayerCollisionComp = PlayerCollisionComp;

},{"../../core/BaseComponent":3,"../../core/BindEntityScript":10,"../../core/TriggerCollisionScript":14,"../../core/util/EntityTypeDefine":35,"../../core/util/Logger":39}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerControlComp = void 0;
/**
 * 角色控制
 */
const EventManager_1 = require("../../core/EventManager");
const JoyStrickCtrl_1 = require("../view/JoyStrickCtrl");
const SceneManager_1 = require("../../core/SceneManager");
const RoleModel_1 = require("../model/RoleModel");
const RoleControlComp_1 = require("./RoleControlComp");
const Role_1 = require("../prefab/Role");
class PlayerControlComp extends RoleControlComp_1.RoleControlComp {
    constructor() {
        super();
        this.cameraTranslate = new Laya.Vector3(0, 0, 0);
        this.gameCamera = SceneManager_1.default.curSence.gameCamera;
    }
    onLoad() {
        super.onLoad();
    }
    init(prefab) {
        super.init(prefab);
        let sphereShape = new Laya.CapsuleColliderShape(0.5, 1.6);
        sphereShape.localOffset = new Laya.Vector3(0, 0.8, 0);
        this.rigidBody.colliderShape = sphereShape;
        let sphereShape2 = new Laya.CapsuleColliderShape(0.5, 1.6);
        sphereShape2.localOffset = new Laya.Vector3(0, 0.8, 0);
        this.character.colliderShape = sphereShape2;
        EventManager_1.default.on(JoyStrickCtrl_1.JoyCmd.STOP, this, this.stopCmd);
        EventManager_1.default.on(JoyStrickCtrl_1.JoyCmd.MOVE, this, this.moveCmd);
        this.preX = this.prefab.transform.position.x;
        this.preZ = this.prefab.transform.position.z;
        this.entity.on(Role_1.RoleEvent.State, this, this.stateChange);
    }
    onDestory() {
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    stateChange(state) {
        if (state == RoleModel_1.RoleState.Die) {
            this._cmdAngle = null;
            this.cameraTranslate = new Laya.Vector3(0, 0, 0);
        }
    }
    stopCmd() {
        this._cmdAngle = null;
        if (!this.entity.model.enableMove()) {
            return;
        }
        this.entity.idle();
        this.cameraTranslate = new Laya.Vector3(0, 0, 0);
    }
    moveCmd(angle, dev) {
        if (!this.entity.model.enableMove()) {
            return;
        }
        this._cmdAngle = 90 - angle;
        if (this._cmdAngle < 0) {
            this._cmdAngle += 360;
        }
        this.entity.run();
    }
    update() {
        super.update();
        // 摄像机跟随角色
        this.cameraTranslate = new Laya.Vector3((this.prefab.transform.position.x - this.preX), 0, (this.prefab.transform.position.z - this.preZ));
        this.gameCamera.translate(this.cameraTranslate);
        this.preX = this.prefab.transform.position.x;
        this.preZ = this.prefab.transform.position.z;
    }
    onDisable() {
        super.onDisable();
    }
}
exports.PlayerControlComp = PlayerControlComp;

},{"../../core/EventManager":11,"../../core/SceneManager":13,"../model/RoleModel":78,"../prefab/Role":82,"../view/JoyStrickCtrl":94,"./RoleControlComp":58}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleAnimComp = void 0;
/**
 * 角色动画
 */
const BaseComponent_1 = require("../../core/BaseComponent");
const Logger_1 = require("../../core/util/Logger");
const LogicScheduler_1 = require("../../core/LogicScheduler");
class RoleAnimComp extends BaseComponent_1.default {
    onLoad() {
        super.onLoad();
    }
    init(animator) {
        this.animator = animator;
        animator.getDefaultState();
        this.animator.getControllerLayer();
    }
    getClipDuration(clipName) {
        let control = this.animator.getControllerLayer();
        let state = control.getAnimatorState(clipName);
        return state.clip.duration();
    }
    play(clipName, config = {}) {
        let control = this.animator.getControllerLayer();
        let state = control.getAnimatorState(clipName);
        if (!state) {
            Logger_1.error("can not find clipName" + clipName);
            return;
        }
        LogicScheduler_1.default.clearAll(this);
        if (config.speed != undefined) {
            this.animator.speed = config.speed;
        }
        else {
            this.animator.speed = 1;
        }
        if (config.loop != undefined) {
            state.clip.islooping = config.loop;
        }
        this.curConfig = config;
        if (config.callFunc != undefined && config.caller != undefined) {
            LogicScheduler_1.default.once(state.clip.duration() * 2000 / this.animator.speed, this, this.animateCallFunc);
        }
        this.animator.crossFade(clipName, 0.3, 0);
    }
    animateCallFunc() {
        this.curConfig.callFunc.call(this.curConfig.caller, this.curConfig.callArgs);
    }
    onDestory() {
        Laya.timer.clearAll(this);
        this.curConfig = null;
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.RoleAnimComp = RoleAnimComp;

},{"../../core/BaseComponent":3,"../../core/LogicScheduler":12,"../../core/util/Logger":39}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleControlComp = void 0;
const BaseComponent_1 = require("../../core/BaseComponent");
const SceneManager_1 = require("../../core/SceneManager");
const CollisionFilterDefine_1 = require("../define/CollisionFilterDefine");
class RoleControlComp extends BaseComponent_1.default {
    constructor() {
        super();
        this.zero = new Laya.Vector3(0, 0, 0);
        // 当前命令角度
        this._cmdAngle = null;
        this.updateComp = true;
        this._logicPrefab = new Laya.Sprite3D();
    }
    init(prefab, ...params) {
        this.prefab = prefab;
        this._logicPrefab.removeSelf();
        SceneManager_1.default.curSence.scene.addChild(this._logicPrefab);
        this._logicPrefab.transform.localPosition = this.prefab.transform.localPosition.clone();
        this.character = this._logicPrefab.addComponent(Laya.CharacterController);
        this.character.canCollideWith = CollisionFilterDefine_1.default.Wall | Laya.Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER;
        this.character.collisionGroup = CollisionFilterDefine_1.default.Player;
        this.rigidBody = this.prefab.addComponent(Laya.Rigidbody3D);
        this.rigidBody.collisionGroup = CollisionFilterDefine_1.default.Player;
        this.rigidBody.isKinematic = true;
    }
    update() {
        if (this._cmdAngle == null) {
            this.character.move(this.zero);
            let localPosition = this._logicPrefab.transform.localPosition;
            this.entity.model.setPosition(localPosition.x, localPosition.y, localPosition.z);
            return;
        }
        let speed = this.entity.model.speed;
        let angularSpeed = this.entity.model.angularSpeed;
        let curRotation = this.entity.model.localRotationEuler;
        let curPosition = this.entity.model.localPosition;
        let curAngle = curRotation.y;
        if (curAngle !== this._cmdAngle) {
            if (curAngle - this._cmdAngle < -180) {
                curAngle += 360;
            }
            if (curAngle - this._cmdAngle > 180) {
                curAngle -= 360;
            }
            if (curAngle > this._cmdAngle) {
                curAngle -= angularSpeed;
                curAngle = curAngle < this._cmdAngle ? this._cmdAngle : curAngle;
            }
            else {
                curAngle += angularSpeed;
                curAngle = curAngle > this._cmdAngle ? this._cmdAngle : curAngle;
            }
            this.entity.model.setRotation(curRotation.x, curAngle, curRotation.z);
        }
        let rad = curAngle * Math.PI / 180;
        let z = Math.cos(rad) * 0.05 * speed;
        let x = Math.sin(rad) * 0.05 * speed;
        this.character.move(new Laya.Vector3(x, 0, z));
        let pos = this._logicPrefab.transform.localPosition;
        this.entity.model.setPosition(pos.x, pos.y, pos.z);
    }
    resetLogicPos() {
        this._logicPrefab.transform.localPosition = this.entity.model.localPosition;
    }
    onLoad() {
        super.onLoad();
    }
    onEnable() {
        super.onEnable();
    }
    onDestory() {
        super.onDestory();
        this._logicPrefab.destroy();
        this._logicPrefab = null;
    }
    onDisable() {
        super.onDisable();
    }
}
exports.RoleControlComp = RoleControlComp;

},{"../../core/BaseComponent":3,"../../core/SceneManager":13,"../define/CollisionFilterDefine":73}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleDriverComp = void 0;
/**
 * 角色控制
 */
const RoleModel_1 = require("../model/RoleModel");
const RoleControlComp_1 = require("./RoleControlComp");
const Role_1 = require("../prefab/Role");
class RoleDriverComp extends RoleControlComp_1.RoleControlComp {
    constructor() {
        super();
    }
    onLoad() {
        super.onLoad();
    }
    init(prefab, shape, offset) {
        super.init(prefab);
        let sphereShape = new Laya.CapsuleColliderShape(shape.x, shape.y);
        sphereShape.localOffset = new Laya.Vector3(offset.x, offset.y, offset.z);
        this.rigidBody.colliderShape = sphereShape;
        let sphereShape2 = new Laya.CapsuleColliderShape(shape.x, shape.y);
        sphereShape2.localOffset = new Laya.Vector3(offset.x, offset.y, offset.z);
        this.character.colliderShape = sphereShape2;
        this.entity.on(Role_1.RoleEvent.State, this, this.stateChange);
    }
    onDestory() {
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    stateChange(state) {
        if (state == RoleModel_1.RoleState.Die) {
            this._cmdAngle = null;
        }
    }
    stopCmd() {
        this._cmdAngle = null;
        if (!this.entity.model.enableMove()) {
            return;
        }
        if (this.entity.model.state != RoleModel_1.RoleState.Attak) {
            this.entity.idle();
        }
    }
    moveCmd(angle, dev) {
        if (!this.entity.model.enableMove()) {
            return;
        }
        this._cmdAngle = 90 - angle;
        if (this._cmdAngle < 0) {
            this._cmdAngle += 360;
        }
        this.entity.run();
    }
    update() {
        super.update();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.RoleDriverComp = RoleDriverComp;

},{"../model/RoleModel":78,"../prefab/Role":82,"./RoleControlComp":58}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleEffectComp = void 0;
const LogicScheduler_1 = require("../../core/LogicScheduler");
const BaseComponent_1 = require("../../core/BaseComponent");
class RoleEffectComp extends BaseComponent_1.default {
    constructor() {
        super();
        this._blinkInterval = 333;
        this._blinkFlag = true;
    }
    playHitEffect(time = 1) {
        this._blinkFlag = false;
        this.hitColor();
        this._curHitTime = Laya.timer.currTimer + time * 1000;
        LogicScheduler_1.default.clear(this, this.blinkLoop);
        LogicScheduler_1.default.loop(this._blinkInterval, this, this.blinkLoop);
    }
    blinkLoop() {
        if (Laya.timer.currTimer >= this._curHitTime) {
            LogicScheduler_1.default.clear(this, this.blinkLoop);
            this.resetColor();
        }
        else {
            this.blink();
        }
    }
    blink() {
        if (this._blinkFlag) {
            this._blinkFlag = false;
            this.hitColor();
        }
        else {
            this._blinkFlag = true;
            this.resetColor();
        }
    }
    hitColor() {
        this.setAlbedoColor(255, 1, 1, 1);
    }
    resetColor() {
        this.setAlbedoColor(1, 1, 1, 1);
    }
    setAlbedoColor(r, g, b, a) {
        let skinnedMeshSprite3D = this.entity.prefab.getChildAt(0).getChildAt(0);
        let material = skinnedMeshSprite3D.skinnedMeshRenderer.material;
        material.albedoColor = new Laya.Vector4(r, g, b, a);
    }
}
exports.RoleEffectComp = RoleEffectComp;

},{"../../core/BaseComponent":3,"../../core/LogicScheduler":12}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigntComp = void 0;
const BaseComponent_1 = require("../../core/BaseComponent");
const ResLoader_1 = require("../../core/util/ResLoader");
const GameResDefine_1 = require("../define/GameResDefine");
const SceneManager_1 = require("../../core/SceneManager");
class SigntComp extends BaseComponent_1.default {
    constructor() {
        super();
        this._resPath = GameResDefine_1.default.SigntRes;
        this._curActive = true;
        this.updateComp = true;
    }
    onLoad() {
        super.onLoad();
        ResLoader_1.default.loadRes(this._resPath, this, () => {
            this.view = ResLoader_1.default.getRes(GameResDefine_1.default.SigntRes).clone();
            SceneManager_1.default.curSence.addChild(this.view);
            this.setActive(false);
        });
    }
    update() {
        if (this.view != null) {
            this.updateViewPos();
        }
    }
    setActive(v) {
        if (v != this._curActive) {
            this._curActive = v;
            this.view.active = v;
        }
    }
    updateViewPos() {
        this.entity.findTarget();
        let playerModel = this.entity.model;
        if (playerModel.attackTarget) {
            this.setActive(true);
            this.view.transform.localPosition = new Laya.Vector3(playerModel.attackTarget.model.localPosition.x, 0.01, playerModel.attackPoint.z);
        }
        else {
            this.setActive(false);
        }
    }
    onDestory() {
        if (this.view) {
            this.view.removeSelf();
            this.view.destroy();
            this.view = null;
        }
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.SigntComp = SigntComp;

},{"../../core/BaseComponent":3,"../../core/SceneManager":13,"../../core/util/ResLoader":41,"../define/GameResDefine":74}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WallRayCastComp = void 0;
const BaseComponent_1 = require("../../core/BaseComponent");
const CollisionFilterDefine_1 = require("../define/CollisionFilterDefine");
const SceneManager_1 = require("../../core/SceneManager");
/**
 * 角色控制
 */
class WallRayCastComp extends BaseComponent_1.default {
    constructor() {
        super();
    }
    onLoad() {
        super.onLoad();
        this.init();
    }
    init() {
        this.ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(-1, 0, 0));
        this.outHitInfo = new Laya.HitResult();
    }
    onDestory() {
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    rayCast() {
        let scene = SceneManager_1.default.curSence.scene;
        let rayOrigin = new Laya.Vector3(0, 0, 0);
        Laya.Vector3.add(this.entity.model.localPosition, new Laya.Vector3(0, 0, 0), rayOrigin);
        this.ray.origin = rayOrigin;
        this.ray.direction = this.entity.model.localRotationEuler.clone();
        //物理射线与碰撞器相交检测
        scene.physicsSimulation.rayCast(this.ray, this.outHitInfo, 2, CollisionFilterDefine_1.default.Ray, CollisionFilterDefine_1.default.Wall);
        if (this.outHitInfo.succeeded) {
            return true;
        }
        else {
            return false;
        }
    }
    turnDir() {
        this.entity.roleDriverComp.moveCmd(this.entity.model.localRotationEuler.y + 90);
    }
    onDisable() {
        super.onDisable();
    }
}
exports.WallRayCastComp = WallRayCastComp;

},{"../../core/BaseComponent":3,"../../core/SceneManager":13,"../define/CollisionFilterDefine":73}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChapterConfig = exports.ChapterConfigData = void 0;
const ResLoader_1 = require("../../core/util/ResLoader");
class ChapterConfigData {
    constructor(config) {
        this._index = config['index'];
        this._chapter = config['chapter'];
        this._level = config['level'];
        this._map = config['map'];
        this._monsterFac = config['monsterFac'];
        this._interval = config['interval'];
        this._array = config['array'];
    }
    get index() {
        return this._index;
    }
    get chapter() {
        return this._chapter;
    }
    get level() {
        return this._level;
    }
    get map() {
        return this._map;
    }
    get monsterFac() {
        return this._monsterFac;
    }
    get interval() {
        return this._interval;
    }
    get array() {
        return this._array;
    }
}
exports.ChapterConfigData = ChapterConfigData;
class ChapterConfig {
    static deserialize() {
        let json = ResLoader_1.default.getRes(ChapterConfig.resPath);
        let dataArr = [];
        let keys = Object.keys(json);
        let data;
        let config;
        for (let i = 0, len = keys.length; i < len; i++) {
            config = json[keys[i]];
            data = new ChapterConfigData(config);
            dataArr.push(data);
        }
        return dataArr;
    }
}
exports.ChapterConfig = ChapterConfig;
ChapterConfig.resPath = "res/config/Chapter.json";

},{"../../core/util/ResLoader":41}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonsterConfig = exports.MonsterConfigData = void 0;
const ResLoader_1 = require("../../core/util/ResLoader");
class MonsterConfigData {
    constructor(config) {
        this._id = config['id'];
        this._name = config['name'];
        this._res = config['res'];
        this._hp = config['hp'];
        this._skin = config['skin'];
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._name;
    }
    get res() {
        return this._res;
    }
    get hp() {
        return this._hp;
    }
    get skin() {
        return this._skin;
    }
}
exports.MonsterConfigData = MonsterConfigData;
class MonsterConfig {
    static deserialize() {
        let json = ResLoader_1.default.getRes(MonsterConfig.resPath);
        let dataArr = [];
        let keys = Object.keys(json);
        let data;
        let config;
        for (let i = 0, len = keys.length; i < len; i++) {
            config = json[keys[i]];
            data = new MonsterConfigData(config);
            dataArr.push(data);
        }
        return dataArr;
    }
}
exports.MonsterConfig = MonsterConfig;
MonsterConfig.resPath = "res/config/Monster.json";

},{"../../core/util/ResLoader":41}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonsterFacConfig = exports.MonsterFacConfigData = void 0;
const ResLoader_1 = require("../../core/util/ResLoader");
class MonsterFacConfigData {
    constructor(config) {
        this._index = config['index'];
        this._stage = config['stage'];
        this._wave = config['wave'];
        this._pos = config['pos'];
        this._monster = config['monster'];
    }
    get index() {
        return this._index;
    }
    get stage() {
        return this._stage;
    }
    get wave() {
        return this._wave;
    }
    get pos() {
        return this._pos;
    }
    get monster() {
        return this._monster;
    }
}
exports.MonsterFacConfigData = MonsterFacConfigData;
class MonsterFacConfig {
    static deserialize() {
        let json = ResLoader_1.default.getRes(MonsterFacConfig.resPath);
        let dataArr = [];
        let keys = Object.keys(json);
        let data;
        let config;
        for (let i = 0, len = keys.length; i < len; i++) {
            config = json[keys[i]];
            data = new MonsterFacConfigData(config);
            dataArr.push(data);
        }
        return dataArr;
    }
}
exports.MonsterFacConfig = MonsterFacConfig;
MonsterFacConfig.resPath = "res/config/MonsterFac.json";

},{"../../core/util/ResLoader":41}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseController_1 = require("../../core/BaseController");
const MonsterBehaviorTree_1 = require("../ai/MonsterBehaviorTree");
const GameResDefine_1 = require("../define/GameResDefine");
class AIBehaviorController extends BaseController_1.default {
    constructor() {
        super();
    }
    start() {
        this.monsterTree = new MonsterBehaviorTree_1.default();
        this.monsterTree.init(GameResDefine_1.default.BehaviorPath);
    }
    monsterTick(target, blackboard) {
        if (this.monsterTree && this.monsterTree.tree) {
            this.monsterTree.tree.tick(target, blackboard);
        }
    }
}
exports.default = AIBehaviorController;

},{"../../core/BaseController":4,"../ai/MonsterBehaviorTree":45,"../define/GameResDefine":74}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIGeneticComp = void 0;
const BaseController_1 = require("../../core/BaseController");
const GeneticOptimisation_1 = require("../../core/ai/genetic/GeneticOptimisation");
const GameManager_1 = require("../GameManager");
const LogicScheduler_1 = require("../../core/LogicScheduler");
const GameCacheData_1 = require("../common/GameCacheData");
const EventManager_1 = require("../../core/EventManager");
var AIGeneticComp;
(function (AIGeneticComp) {
    AIGeneticComp["CurStep"] = "CurStep";
    AIGeneticComp["Evolve"] = "Evolve";
})(AIGeneticComp = exports.AIGeneticComp || (exports.AIGeneticComp = {}));
class AIGeneticController extends BaseController_1.default {
    constructor() {
        super();
        this._totalStepsPerEpoch = GameCacheData_1.default.Ins.evolutionCycle;
        this._stepsPer = 1;
    }
    generateInitial(mutateProbability = 0.1, selectionMethod = GeneticOptimisation_1.SelectionMethod.Competitive) {
        const monsterList = GameManager_1.default.MonsterController.monsterList;
        this._nodeCount = monsterList.length;
        this._evolver = new GeneticOptimisation_1.default(this._nodeCount, mutateProbability, selectionMethod);
        this._epoch = 0;
        this._currentStepsInEpoch = 0;
        GameCacheData_1.default.Ins.evolutionCount = 0;
        for (let i = 0; i < monsterList.length; i++) {
            let monster = monsterList[i];
            this._evolver.population.push(monster.monsterAIComp.network);
        }
        this._evolver.RandomizePopulation();
        LogicScheduler_1.default.loopFrame(1, this, this.update);
    }
    update() {
        if (this._currentStepsInEpoch > this._totalStepsPerEpoch) {
            this.evolve();
        }
        for (var i = 0; i < this._stepsPer; i++) {
            this.trainingUpdate();
        }
    }
    trainingUpdate() {
        this._currentStepsInEpoch++;
        EventManager_1.default.emit(AIGeneticComp.CurStep, this._currentStepsInEpoch);
        const monsterList = GameManager_1.default.MonsterController.monsterList;
        for (let i = 0; i < monsterList.length; i++) {
            let monster = monsterList[i];
            monster.monsterAIComp.thinkDeeply();
        }
    }
    evolve() {
        GameCacheData_1.default.Ins.evolutionCount += 1;
        EventManager_1.default.emit(AIGeneticComp.Evolve);
        let fitnesses = [];
        const monsterList = GameManager_1.default.MonsterController.monsterList;
        for (let i = 0; i < monsterList.length; i++) {
            let monster = monsterList[i];
            fitnesses[i] = monster.monsterAIComp.fitness;
        }
        // fitnesses.sort((x,y)=>y-x);
        // let max = fitnesses[0];
        // log(`Epoch ${this._epoch} finished with highest fitnesses ${max}.`)
        this._evolver.Evolve(fitnesses);
        for (let i = 0; i < monsterList.length; i++) {
            let monster = monsterList[i];
            monster.monsterAIComp.network = this._evolver.population[i];
        }
        this._epoch++;
        this.restoreInitial();
    }
    restoreInitial() {
        this._currentStepsInEpoch = 0;
        const monsterList = GameManager_1.default.MonsterController.monsterList;
        for (let i = 0; i < monsterList.length; i++) {
            let monster = monsterList[i];
            monster.reset();
        }
    }
    onDestory() {
        super.onDestory();
        LogicScheduler_1.default.clearAll(this);
        this._evolver = null;
    }
}
exports.default = AIGeneticController;

},{"../../core/BaseController":4,"../../core/EventManager":11,"../../core/LogicScheduler":12,"../../core/ai/genetic/GeneticOptimisation":28,"../GameManager":43,"../common/GameCacheData":46}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameResDefine_1 = require("../define/GameResDefine");
const ResLoader_1 = require("../../core/util/ResLoader");
const Bullet_1 = require("../prefab/Bullet");
const BaseController_1 = require("../../core/BaseController");
class BulletController extends BaseController_1.default {
    constructor() {
        super();
        this.allBulletList = [];
        this.activeBulletList = [];
        this.bulletPool = new Map;
    }
    getBullet(type) {
        let pool = this.bulletPool.get(type);
        if (pool && pool.length > 0) {
            let bullet = pool.pop();
            bullet.prefab.active = true;
            this.activeBulletList.push(bullet);
            return bullet;
        }
        else {
            return this.createBullet(type);
        }
    }
    createBullet(type) {
        switch (type) {
            case Bullet_1.BulletType.Normal:
                let bullet = new Bullet_1.default(type);
                bullet.init();
                this.allBulletList.push(bullet);
                this.activeBulletList.push(bullet);
                return bullet;
            default:
                break;
        }
    }
    recycleBullet(bullet) {
        bullet.prefab.active = false;
        let curIndex = this.activeBulletList.indexOf(bullet);
        if (curIndex > -1) {
            this.activeBulletList.splice(curIndex, 1);
        }
        let type = bullet.type;
        let pool = this.bulletPool.get(type);
        if (pool) {
            pool.push(bullet);
        }
        else {
            this.bulletPool.set(type, [bullet]);
        }
    }
    prepareBullet(context, callBack) {
        let res = GameResDefine_1.default.BulletRes;
        ResLoader_1.default.loadRes(res, this, () => {
            callBack && callBack.call(context);
        });
    }
    onDestory() {
        super.onDestory();
        this.bulletPool.clear();
        for (let i = 0; i < this.allBulletList.length; i++) {
            let bullet = this.allBulletList[i];
            bullet.onDestory();
        }
        this.allBulletList.length = 0;
        this.activeBulletList.length = 0;
    }
}
exports.default = BulletController;

},{"../../core/BaseController":4,"../../core/util/ResLoader":41,"../define/GameResDefine":74,"../prefab/Bullet":79}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StageCmd = void 0;
const BaseController_1 = require("../../core/BaseController");
const GameCacheData_1 = require("../common/GameCacheData");
const GameConfigData_1 = require("../common/GameConfigData");
const GameManager_1 = require("../GameManager");
const EventManager_1 = require("../../core/EventManager");
const LogicScheduler_1 = require("../../core/LogicScheduler");
var StageCmd;
(function (StageCmd) {
    StageCmd["Pause"] = "Pause";
    StageCmd["Resume"] = "Resume";
    StageCmd["AddScale"] = "AddScale";
    StageCmd["SubScale"] = "SubScale";
    StageCmd["CurScale"] = "CurScale";
    StageCmd["PlayerFight"] = "PlayerFight";
})(StageCmd = exports.StageCmd || (exports.StageCmd = {}));
class GameStageController extends BaseController_1.default {
    constructor() {
        super();
        this._curWave = 0;
    }
    start() {
        this.createMonsterGroup();
        EventManager_1.default.on(StageCmd.Pause, this, this.pause);
        EventManager_1.default.on(StageCmd.Resume, this, this.resume);
        EventManager_1.default.on(StageCmd.AddScale, this, this.addScale);
        EventManager_1.default.on(StageCmd.SubScale, this, this.subScale);
        EventManager_1.default.on(StageCmd.PlayerFight, this, this.switchPlayerFight);
    }
    pause() {
        LogicScheduler_1.default.Ins.pause();
        Laya.timer.pause();
        Laya.updateTimer.pause();
        Laya.physicsTimer.pause();
    }
    resume() {
        LogicScheduler_1.default.Ins.resume();
        Laya.updateTimer.resume();
        Laya.timer.resume();
        Laya.physicsTimer.resume();
    }
    addScale() {
        Laya.timer.scale += 0.2;
        Laya.physicsTimer.scale += 0.2;
        EventManager_1.default.emit(StageCmd.CurScale, Laya.timer.scale);
    }
    subScale() {
        if (Laya.timer.scale >= 0.1) {
            Laya.timer.scale -= 0.1;
            Laya.physicsTimer.scale -= 0.1;
            EventManager_1.default.emit(StageCmd.CurScale, Laya.timer.scale);
        }
    }
    switchPlayerFight() {
        GameManager_1.default.PlayerController.setPlayerFight();
    }
    createMonsterGroup() {
        let curChapterIndex = GameCacheData_1.default.Ins.curChapterIndex;
        let chapterData = GameConfigData_1.default.Ins.getChapterConfigData(curChapterIndex);
        this._curWave++;
        let monsterData = GameConfigData_1.default.Ins.getMonsterFacByWave(chapterData.monsterFac, this._curWave);
        for (let i = 0; i < monsterData.length; i++) {
            let curData = monsterData[i];
            GameManager_1.default.MonsterController.createMonsterAsyn(curData.monster, curData.pos);
        }
        GameManager_1.default.AIBehaviorController.start();
        Laya.timer.once(2000, this, () => {
            GameManager_1.default.AIGeneticController.generateInitial();
        });
    }
    onDestory() {
        EventManager_1.default.offAll(this);
    }
}
exports.default = GameStageController;

},{"../../core/BaseController":4,"../../core/EventManager":11,"../../core/LogicScheduler":12,"../GameManager":43,"../common/GameCacheData":46,"../common/GameConfigData":48}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseController_1 = require("../../core/BaseController");
const Monster_1 = require("../prefab/Monster");
const ResLoader_1 = require("../../core/util/ResLoader");
const GameConfigData_1 = require("../common/GameConfigData");
const GameManager_1 = require("../GameManager");
const SkillController_1 = require("./SkillController");
class MonsterController extends BaseController_1.default {
    constructor() {
        super();
        this.sIndex = 0;
        this.monsterList = [];
        this.monsterPool = new Map;
    }
    getMonster(id, pos = null) {
        let pool = this.monsterPool.get(id);
        if (pool && pool.length > 0) {
            return pool.pop();
        }
        else {
            return this.createMonster(id, pos);
        }
    }
    createMonster(id, pos = null) {
        let monster = new Monster_1.default(id);
        monster.init(pos);
        this.monsterList.push(monster);
        monster.model.sid = this.sIndex;
        this.sIndex++;
        return monster;
    }
    recycleMonster(monster) {
        let id = monster.id;
        let pool = this.monsterPool.get(id);
        if (pool) {
            pool.push(monster);
        }
        else {
            this.monsterPool.set(id, [monster]);
        }
    }
    createMonsterAsyn(id, pos = null) {
        let monsterData = GameConfigData_1.default.Ins.getMonsterConfigData(id);
        let res = monsterData.res;
        ResLoader_1.default.loadRes(res, this, () => {
            let monster = this.getMonster(id, pos);
            // 创建技能
            GameManager_1.default.SkillController.createSkill(SkillController_1.SkillType.Attack, monster);
        });
    }
    onDestory() {
        super.onDestory();
        this.monsterPool.clear();
        for (let i = 0; i < this.monsterList.length; i++) {
            let monster = this.monsterList[i];
            monster.onDestory();
        }
        this.monsterList.length = 0;
    }
}
exports.default = MonsterController;

},{"../../core/BaseController":4,"../../core/util/ResLoader":41,"../GameManager":43,"../common/GameConfigData":48,"../prefab/Monster":80,"./SkillController":72}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 玩家
 */
const BaseController_1 = require("../../core/BaseController");
const Player_1 = require("../prefab/Player");
const ResLoader_1 = require("../../core/util/ResLoader");
const GameResDefine_1 = require("../define/GameResDefine");
const GameManager_1 = require("../GameManager");
const SkillController_1 = require("./SkillController");
class PlayerController extends BaseController_1.default {
    constructor() {
        super();
    }
    createPlayer() {
        let player = new Player_1.default();
        player.init();
        this.curPlayer = player;
    }
    createPlayerAsyn(callBack = null) {
        let res = GameResDefine_1.default.HeroRes;
        ResLoader_1.default.loadRes(res, this, (sprite) => {
            let player = new Player_1.default();
            player.init();
            this.curPlayer = player;
            callBack && callBack();
            // 创建技能
            GameManager_1.default.SkillController.createSkill(SkillController_1.SkillType.Attack, player);
        });
    }
    setPlayerFight() {
        if (this.curPlayer) {
            this.curPlayer.model.isFight = !this.curPlayer.model.isFight;
        }
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = PlayerController;

},{"../../core/BaseController":4,"../../core/util/ResLoader":41,"../GameManager":43,"../define/GameResDefine":74,"../prefab/Player":81,"./SkillController":72}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkillType = void 0;
const BaseController_1 = require("../../core/BaseController");
const NormallAttackSkill_1 = require("../skill/NormallAttackSkill");
const GameResDefine_1 = require("../define/GameResDefine");
const ResLoader_1 = require("../../core/util/ResLoader");
var SkillType;
(function (SkillType) {
    SkillType["Attack"] = "Attack";
})(SkillType = exports.SkillType || (exports.SkillType = {}));
class SkillController extends BaseController_1.default {
    constructor() {
        super();
    }
    createSkill(skilltype, owner) {
        switch (skilltype) {
            case SkillType.Attack:
                this.prepareAttackSkill(owner);
            default:
                break;
        }
    }
    prepareAttackSkill(owner) {
        let res = GameResDefine_1.default.BulletRes;
        ResLoader_1.default.loadRes(res, this, () => {
            let skill = new NormallAttackSkill_1.default();
            skill.init(owner);
            owner.addSkill(skill);
        });
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = SkillController;

},{"../../core/BaseController":4,"../../core/util/ResLoader":41,"../define/GameResDefine":74,"../skill/NormallAttackSkill":92}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CollisionFilterDefine {
}
exports.default = CollisionFilterDefine;
// 玩家
CollisionFilterDefine.Player = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1;
// 子弹
CollisionFilterDefine.Bullet = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2;
// 墙体
CollisionFilterDefine.Wall = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3;
// 探针
CollisionFilterDefine.Ray = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class GameResDefine {
}
exports.default = GameResDefine;
// 炮塔
GameResDefine.TurretRes = "res/3d/GameObject.lh";
// 天空盒
GameResDefine.SkyBoxRes = "res/3d/skyBox/skyBox1/skyBox.lmat";
// 游戏场景
GameResDefine.GameMap = "res/3d/game_scene.lh";
// 角色
GameResDefine.HeroRes = "res/3d/tailed_fox.lh";
// 子弹
GameResDefine.BulletRes = "res/3d/bullet.lh";
// 怪物
GameResDefine.MonsterRes = "res/3d/gun_girl.lh";
// 准星
GameResDefine.SigntRes = "res/3d/signt.lh";
// 战场包
GameResDefine.Battle_fuj = "res/gui/Battle.bin";
GameResDefine.Battle_atlas0 = "res/gui/Battle_atlas0.png";
// 行为树
GameResDefine.BehaviorPath = "res/behavior/monster1_ai.json";

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../../core/BaseModel");
class BulletModel extends BaseModel_1.default {
    constructor(owner) {
        super(owner.uuid);
        this._owner = owner;
        this.init();
    }
    init() {
    }
    setPosition(x, y, z) {
        super.setPosition(x, y, z);
        this._owner.prefab.transform.localPosition = this.localPosition;
    }
    setRotation(x, y, z) {
        super.setRotation(x, y, z);
        this._owner.prefab.transform.localRotationEuler = this.localRotationEuler;
    }
    setScale(x, y, z) {
        super.setScale(x, y, z);
        this._owner.prefab.transform.localScale = this.localScale;
    }
    onDestory() {
        super.onDestory();
        this._owner = null;
    }
}
exports.default = BulletModel;

},{"../../core/BaseModel":7}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RoleModel_1 = require("./RoleModel");
const Role_1 = require("../prefab/Role");
const GameConfigData_1 = require("../common/GameConfigData");
class MonsterModel extends RoleModel_1.default {
    constructor(owner) {
        super(owner);
        this._attackSpeed = 1;
        this._speed = 2;
        this._attackTrigger = 700; // 攻击触发时间
        this._attackRad = 20; // 攻击半径attackTarget
        this._evade = 14; // 躲避半径attackTarget
        this._angularSpeed = 20;
        this._fitness = 300; // 种族值
        this._owner = owner;
        this.init();
    }
    init() {
        let configData = GameConfigData_1.default.Ins.getMonsterConfigData(this._owner.id);
        this.curHp = configData.hp;
        this.maxHp = configData.hp;
        this.name = configData.name;
    }
    reset() {
        let configData = GameConfigData_1.default.Ins.getMonsterConfigData(this._owner.id);
        this.curHp = configData.hp;
        this.state = RoleModel_1.RoleState.Idle;
        this.fitness = 100;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get sid() {
        return this._sid;
    }
    set sid(value) {
        this._sid = value;
    }
    get fitness() {
        return this._fitness;
    }
    set fitness(value) {
        this._fitness = value;
    }
    get evade() {
        return this._evade;
    }
    set evade(value) {
        this._evade = value;
    }
    get state() {
        return this._state;
    }
    set state(v) {
        this._state = v;
        this._owner.emit(Role_1.RoleEvent.State, this._state);
    }
    onDestory() {
        super.onDestory();
        this._owner = null;
    }
}
exports.default = MonsterModel;

},{"../common/GameConfigData":48,"../prefab/Role":82,"./RoleModel":78}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RoleModel_1 = require("./RoleModel");
const Role_1 = require("../prefab/Role");
class PlayerModel extends RoleModel_1.default {
    constructor(owner) {
        super(owner);
        this._attackSpeed = 1;
        this._speed = 2;
        this._attackTrigger = 1000; // 攻击触发时间
        this._attackRad = 1000; // 攻击半径attackTarget
        this._angularSpeed = 20;
        this._isFight = false; // 是否攻击
        this.init();
    }
    get isFight() {
        return this._isFight;
    }
    set isFight(value) {
        this._isFight = value;
    }
    init() {
        this.curHp = 100;
        this.maxHp = 100;
    }
    get state() {
        return this._state;
    }
    set state(v) {
        this._state = v;
        this._owner.emit(Role_1.RoleEvent.State, this._state);
    }
    enableAttack() {
        if (this._isFight == false) {
            return false;
        }
        if (this._state == RoleModel_1.RoleState.Idle) {
            return true;
        }
        return false;
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = PlayerModel;

},{"../prefab/Role":82,"./RoleModel":78}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleState = void 0;
const BaseModel_1 = require("../../core/BaseModel");
var RoleState;
(function (RoleState) {
    RoleState["Idle"] = "Idle";
    RoleState["Run"] = "Run";
    RoleState["Attak"] = "Attak";
    RoleState["Hit"] = "Hit";
    RoleState["Die"] = "Die";
})(RoleState = exports.RoleState || (exports.RoleState = {}));
class RoleModel extends BaseModel_1.default {
    constructor(owner) {
        super(owner.uuid);
        this._owner = owner;
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    get velocity() {
        return this._velocity;
    }
    set velocity(value) {
        this._velocity = value;
    }
    get attackPoint() {
        if (this.attackTarget) {
            return this.attackTarget.model.localPosition;
        }
        return null;
    }
    get attackSpeed() {
        return this._attackSpeed;
    }
    get angularSpeed() {
        return this._angularSpeed;
    }
    set attackSpeed(value) {
        this._attackSpeed = value;
    }
    get speed() {
        return this._speed;
    }
    get maxHp() {
        return this._maxHp;
    }
    set maxHp(v) {
        this._maxHp = v;
    }
    get curHp() {
        return this._curHp;
    }
    set curHp(v) {
        this._curHp = v;
    }
    get state() {
        return this._state;
    }
    set state(v) {
        this._state = v;
    }
    addHp(v) {
        this._curHp += v;
        this._curHp = this._curHp < 0 ? 0 : this._curHp;
    }
    addMaxHp(v) {
        this._maxHp += v;
    }
    enableAttack() {
        if (this._state == RoleState.Idle) {
            return true;
        }
        return false;
    }
    /**
     * 能否被攻击
     */
    enableHit() {
        if (this._state == RoleState.Die) {
            return false;
        }
        return true;
    }
    enableMove() {
        if (this._state != RoleState.Die) {
            return true;
        }
        return false;
    }
    get attackRad() {
        return this._attackRad;
    }
    get attackTrigger() {
        return this._attackTrigger;
    }
    setPosition(x, y, z) {
        super.setPosition(x, y, z);
        this._owner.prefab.transform.localPosition = this.localPosition;
    }
    setRotation(x, y, z) {
        super.setRotation(x, y, z);
        this._owner.prefab.transform.localRotationEuler = this.localRotationEuler;
    }
    onDestory() {
        this.attackTarget = null;
        this._owner = null;
        super.onDestory();
    }
}
exports.default = RoleModel;

},{"../../core/BaseModel":7}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulletType = void 0;
const BaseEntity_1 = require("../../core/BaseEntity");
const BulletModel_1 = require("../model/BulletModel");
const GameResDefine_1 = require("../define/GameResDefine");
const SceneManager_1 = require("../../core/SceneManager");
const ResLoader_1 = require("../../core/util/ResLoader");
const BulletCollisionComp_1 = require("../commponent/BulletCollisionComp");
const MoveByAction_1 = require("../../core/action/MoveByAction");
const MathUtil_1 = require("../../core/util/MathUtil");
const CallFuncAction_1 = require("../../core/action/CallFuncAction");
const SequenceAction_1 = require("../../core/action/SequenceAction");
const GameManager_1 = require("../GameManager");
const BindEntityScript_1 = require("../../core/BindEntityScript");
const EntityTypeDefine_1 = require("../../core/util/EntityTypeDefine");
const BulletTrajectoryComp_1 = require("../commponent/BulletTrajectoryComp");
const ActionEase_1 = require("../../core/action/ActionEase");
const CollisionFilterDefine_1 = require("../define/CollisionFilterDefine");
var BulletType;
(function (BulletType) {
    BulletType["Normal"] = "Normal";
})(BulletType = exports.BulletType || (exports.BulletType = {}));
class Bullet extends BaseEntity_1.default {
    constructor(type) {
        super();
        this._entityType = EntityTypeDefine_1.EntityType.Bullet;
        this._model = new BulletModel_1.default(this);
        this.type = type;
    }
    init() {
        let res = GameResDefine_1.default.BulletRes;
        this.prefab = ResLoader_1.default.getRes(res).clone();
        // this.prefab.getChildAt(0).getComponent(Laya.PhysicsCollider).isTrigger = true;
        SceneManager_1.default.curSence.scene.addChild(this.prefab);
        // 绑定脚本
        let bindEntityScript = this.prefab.addComponent(BindEntityScript_1.default);
        bindEntityScript.setEntity(this);
        // 碰撞组件
        let bulletCollisionComp = this.addComponent(BulletCollisionComp_1.BulletCollisionComp);
        bulletCollisionComp.init(this.prefab);
        // 弹道组件
        this.bulletTrajectoryComp = this.addComponent(BulletTrajectoryComp_1.BulletTrajectoryComp);
    }
    get curUser() {
        return this._curUser;
    }
    get curUserUuid() {
        return this._curUserUuid;
    }
    setUser(user) {
        this._curUser = user;
        this._curUserUuid = user.uuid;
        let physicsCollider = this.prefab.getChildAt(0).getComponent(Laya.PhysicsCollider);
        physicsCollider.collisionGroup = CollisionFilterDefine_1.default.Bullet;
        physicsCollider.canCollideWith = CollisionFilterDefine_1.default.Player;
    }
    shoot(pos, rotate) {
        let delat = 0.5;
        let zDel = delat * Math.cos(MathUtil_1.angle2rad(rotate.y));
        let xDel = delat * Math.sin(MathUtil_1.angle2rad(rotate.y));
        this.model.setPosition(pos.x + xDel, pos.y + 1, pos.z + zDel);
        this.removeAllActions();
        let range = 30;
        let zAim = range * Math.cos(MathUtil_1.angle2rad(rotate.y));
        let xAim = range * Math.sin(MathUtil_1.angle2rad(rotate.y));
        let action1 = new MoveByAction_1.default(1.5, new Laya.Vector3(xAim, -1, zAim)).easing(new ActionEase_1.EaseOut(1));
        //let action1 = new BezierByAction(2, [new Laya.Vector3(pos.x + xAim/2, 16, pos.y + zAim/2), new Laya.Vector3(xAim, 0, zAim)]);
        let action2 = new CallFuncAction_1.default(this.recycleBullet, this);
        let action = new SequenceAction_1.default([action1, action2]);
        this.runAction(action);
    }
    recycleBullet() {
        this._curUser = null;
        GameManager_1.default.BulletController.recycleBullet(this);
    }
    removeBullet() {
        this.removeAllActions();
        this.recycleBullet();
    }
    onDestory() {
        super.onDestory();
        this.prefab.destroy();
        this._model && this._model.onDestory();
        this._model = null;
        this._curUser = null;
    }
}
exports.default = Bullet;

},{"../../core/BaseEntity":5,"../../core/BindEntityScript":10,"../../core/SceneManager":13,"../../core/action/ActionEase":17,"../../core/action/CallFuncAction":19,"../../core/action/MoveByAction":23,"../../core/action/SequenceAction":26,"../../core/util/EntityTypeDefine":35,"../../core/util/MathUtil":40,"../../core/util/ResLoader":41,"../GameManager":43,"../commponent/BulletCollisionComp":50,"../commponent/BulletTrajectoryComp":51,"../define/CollisionFilterDefine":73,"../define/GameResDefine":74,"../model/BulletModel":75}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MonsterModel_1 = require("../model/MonsterModel");
const ResLoader_1 = require("../../core/util/ResLoader");
const SceneManager_1 = require("../../core/SceneManager");
const MonsterCollisionComp_1 = require("../commponent/MonsterCollisionComp");
const GameConfigData_1 = require("../common/GameConfigData");
const BindEntityScript_1 = require("../../core/BindEntityScript");
const RoleAnimComp_1 = require("../commponent/RoleAnimComp");
const EntityTypeDefine_1 = require("../../core/util/EntityTypeDefine");
const HpBarComp_1 = require("../commponent/HpBarComp");
const Role_1 = require("./Role");
const MathUtil_1 = require("../../core/util/MathUtil");
const GameManager_1 = require("../GameManager");
const RoleDriverComp_1 = require("../commponent/RoleDriverComp");
const MonsterAIComp_1 = require("../commponent/MonsterAIComp");
const RoleModel_1 = require("../model/RoleModel");
const RoleEffectComp_1 = require("../commponent/RoleEffectComp");
const WallRayCastComp_1 = require("../commponent/WallRayCastComp");
class Monster extends Role_1.default {
    constructor(id) {
        super();
        this._entityType = EntityTypeDefine_1.EntityType.Monster;
        this.id = id;
    }
    init(pos) {
        this._model = new MonsterModel_1.default(this);
        this._model.id = this.id;
        this.skillGroup = [];
        let monsterData = GameConfigData_1.default.Ins.getMonsterConfigData(this.id);
        let res = monsterData.res;
        this.prefab = ResLoader_1.default.getRes(res).clone();
        this._model.setPosition(pos[0], pos[1], pos[2]);
        SceneManager_1.default.curSence.scene.addChild(this.prefab);
        // 动画组件
        let anim = this.prefab.getChildAt(0).getComponent(Laya.Animator);
        this.animComp = this.addComponent(RoleAnimComp_1.RoleAnimComp);
        this.animComp.init(anim);
        this.idle();
        // 绑定脚本
        let bindEntityScript = this.prefab.addComponent(BindEntityScript_1.default);
        bindEntityScript.setEntity(this);
        // 碰撞组件
        let monsterCollisionComp = this.addComponent(MonsterCollisionComp_1.MonsterCollisionComp);
        monsterCollisionComp.init(this.prefab);
        // 血量组件
        this.hpBarComp = this.addComponent(HpBarComp_1.HpBarComp);
        this.updateHpBar();
        // 角色驾驶
        this.roleDriverComp = this.addComponent(RoleDriverComp_1.RoleDriverComp);
        this.roleDriverComp.init(this.prefab, new Laya.Vector2(0.7, 1.6), new Laya.Vector3(0, 0.8, 0));
        // 角色效果
        this.roleEffectComp = this.addComponent(RoleEffectComp_1.RoleEffectComp);
        // 墙体射线探针
        this.wallRayCastComp = this.addComponent(WallRayCastComp_1.WallRayCastComp);
        // 深度学习AI组件
        this.monsterAIComp = this.addComponent(MonsterAIComp_1.MonsterAIComp);
        // 行为树组件
        //  let monsterBTComp = this.addComponent(MonsterBTComp);
    }
    // 锁定目标
    lockOnTarget() {
        this.findTarget();
        let playerPos = this.model.localPosition;
        let target = this.model.attackTarget;
        if (target) {
            let angle = MathUtil_1.getAngleByVector(target.model.localPosition.x - playerPos.x, target.model.localPosition.z - playerPos.z);
            this.model.setRotation(this.model.localRotationEuler.x, angle, this.model.localRotationEuler.z);
        }
    }
    // 被击中
    hit() {
        if (this._model.state == RoleModel_1.RoleState.Idle) {
            this._model.state = RoleModel_1.RoleState.Hit;
            this.animComp.play("Hit", { caller: this, callFunc: this.resetIdle });
        }
        this.monsterAIComp && this.monsterAIComp.addFitness(-10);
        this.roleEffectComp.playHitEffect(0);
    }
    // 击中目标
    onHit() {
        this.monsterAIComp && this.monsterAIComp.addFitness(10);
    }
    die() {
        super.die();
        this.monsterAIComp && this.monsterAIComp.addFitness(-100);
    }
    reset() {
        let x = MathUtil_1.getRandom(-5, 5);
        let z = MathUtil_1.getRandom(-5, 5);
        this._model.setPosition(x, 0, z);
        this.roleDriverComp.resetLogicPos();
        this.model.reset();
        this.updateHpBar();
    }
    findTarget() {
        // 寻找目标 距离最近的目标
        let target = null;
        let targetDis = Number.MAX_VALUE;
        let playerPos = this.model.localPosition;
        // const player = GameManager.PlayerController.curPlayer;
        // let dx = Math.abs(player.model.localPosition.x - playerPos.x);
        // let dz = Math.abs(player.model.localPosition.z - playerPos.z);
        // if (dx <= this.model.attackRad && dz <= this.model.attackRad && player.model.enableHit()) {
        //     // 在攻击半径范围内
        //     let curDis = dx*dx + dz*dz;
        //     if (curDis < targetDis) {
        //         target = player;
        //         targetDis = curDis;
        //     }
        // }
        const monsterList = GameManager_1.default.MonsterController.monsterList;
        for (let i = 0; i < monsterList.length; i++) {
            const monster = monsterList[i];
            let dx = Math.abs(monster.model.localPosition.x - playerPos.x);
            let dz = Math.abs(monster.model.localPosition.z - playerPos.z);
            if (dx <= this.model.attackRad && dz <= this.model.attackRad && monster.uuid != this.uuid && monster.model.enableHit()) {
                // 在攻击半径范围内
                let curDis = dx * dx + dz * dz;
                if (curDis < targetDis) {
                    target = monster;
                    targetDis = curDis;
                }
            }
        }
        this.model.attackTarget = target;
        if (target) {
            return true;
        }
        else {
            return false;
        }
    }
    watchBullet() {
        const bulletList = GameManager_1.default.BulletController.activeBulletList;
        for (let i = 0; i < bulletList.length; i++) {
            const bullet = bulletList[i];
            let bulletVec = bullet.bulletTrajectoryComp.calcuVector();
            if (bulletVec && bullet.curUserUuid != this.uuid) {
                let x = this.model.localPosition.x - bullet.model.localPosition.x;
                let z = this.model.localPosition.z - bullet.model.localPosition.z;
                let curPosVec = new Laya.Vector2(x, z);
                let cosValue = MathUtil_1.get2VectorAngle(bulletVec, curPosVec);
                if (cosValue > 0.9) {
                    this.model.dodgeVec = new Laya.Vector2(-1 * curPosVec.y, curPosVec.x);
                    // this.model.dodgeVec = new Laya.Vector2(curPosVec.y, -1 * curPosVec.x);
                    return true;
                }
            }
        }
        return false;
    }
    dodgeBullet() {
        const bulletList = GameManager_1.default.BulletController.activeBulletList;
        let angle = -1;
        for (let i = 0; i < bulletList.length; i++) {
            const bullet = bulletList[i];
            let bulletVec = bullet.bulletTrajectoryComp.calcuVector();
            if (bulletVec && bullet.curUserUuid != this.uuid) {
                let x = this.model.localPosition.x - bullet.model.localPosition.x;
                let z = this.model.localPosition.z - bullet.model.localPosition.z;
                let curPosVec = new Laya.Vector2(x, z);
                let cosValue = MathUtil_1.get2VectorAngle(bulletVec, curPosVec);
                if (cosValue > 0.9) {
                    angle = MathUtil_1.getAngleByVector(-1 * curPosVec.y, curPosVec.x);
                    return angle;
                }
            }
        }
        return angle;
    }
    watchBulletPos() {
        const bulletList = GameManager_1.default.BulletController.activeBulletList;
        let x = -100;
        let z = -100;
        for (let i = 0; i < bulletList.length; i++) {
            const bullet = bulletList[i];
            let bulletVec = bullet.bulletTrajectoryComp.calcuVector();
            if (bulletVec && bullet.curUserUuid != this.uuid) {
                x = this.model.localPosition.x - bullet.model.localPosition.x;
                z = this.model.localPosition.z - bullet.model.localPosition.z;
                let curPosVec = new Laya.Vector2(x, z);
                let cosValue = MathUtil_1.get2VectorAngle(bulletVec, curPosVec);
                if (cosValue > 0.9) {
                    return [x, z];
                }
            }
        }
        return [x, z];
    }
    onDestory() {
        super.onDestory();
        this.prefab.destroy();
        this._model && this._model.onDestory();
        this._model = null;
    }
}
exports.default = Monster;

},{"../../core/BindEntityScript":10,"../../core/SceneManager":13,"../../core/util/EntityTypeDefine":35,"../../core/util/MathUtil":40,"../../core/util/ResLoader":41,"../GameManager":43,"../common/GameConfigData":48,"../commponent/HpBarComp":52,"../commponent/MonsterAIComp":53,"../commponent/MonsterCollisionComp":54,"../commponent/RoleAnimComp":57,"../commponent/RoleDriverComp":59,"../commponent/RoleEffectComp":60,"../commponent/WallRayCastComp":62,"../model/MonsterModel":76,"../model/RoleModel":78,"./Role":82}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResLoader_1 = require("../../core/util/ResLoader");
const GameResDefine_1 = require("../define/GameResDefine");
const RoleAnimComp_1 = require("../commponent/RoleAnimComp");
const PlayerControlComp_1 = require("../commponent/PlayerControlComp");
const SceneManager_1 = require("../../core/SceneManager");
const HpBarComp_1 = require("../commponent/HpBarComp");
const PlayerCollisionComp_1 = require("../commponent/PlayerCollisionComp");
const GameManager_1 = require("../GameManager");
const BindEntityScript_1 = require("../../core/BindEntityScript");
const EntityTypeDefine_1 = require("../../core/util/EntityTypeDefine");
const SigntComp_1 = require("../commponent/SigntComp");
const MathUtil_1 = require("../../core/util/MathUtil");
const Role_1 = require("./Role");
const PlayerModel_1 = require("../model/PlayerModel");
const RoleModel_1 = require("../model/RoleModel");
const RotateToAction_1 = require("../../core/action/RotateToAction");
const ShadowMaterial_1 = require("../shader/ShadowMaterial");
const Util_1 = require("../../core/util/Util");
class Player extends Role_1.default {
    constructor() {
        super();
        this._entityType = EntityTypeDefine_1.EntityType.Player;
    }
    init() {
        this.skillGroup = [];
        this._model = new PlayerModel_1.default(this);
        let res = GameResDefine_1.default.HeroRes;
        this.prefab = ResLoader_1.default.getRes(res).clone();
        SceneManager_1.default.curSence.addPlayer(this);
        let renderer = Util_1.getSprite3DRenderer(this.prefab);
        let oldMaterial = renderer.material;
        let texture = oldMaterial.albedoTexture;
        let shadowMaterial = new ShadowMaterial_1.default();
        shadowMaterial.albedoTexture = texture;
        renderer.sharedMaterial = shadowMaterial;
        // 绑定脚本
        let bindEntityScript = this.prefab.addComponent(BindEntityScript_1.default);
        bindEntityScript.setEntity(this);
        // 动画组件
        let anim = this.prefab.getChildAt(0).getComponent(Laya.Animator);
        this.animComp = this.addComponent(RoleAnimComp_1.RoleAnimComp);
        this.animComp.init(anim);
        this.idle();
        // 控制组件
        let playerControlComp = this.addComponent(PlayerControlComp_1.PlayerControlComp);
        playerControlComp.init(this.prefab);
        // 碰撞组件
        let playerCollisionComp = this.addComponent(PlayerCollisionComp_1.PlayerCollisionComp);
        playerCollisionComp.init(this.prefab);
        // 血量组件
        this.hpBarComp = this.addComponent(HpBarComp_1.HpBarComp);
        this.updateHpBar();
        // 准星组件
        this.signt = this.addComponent(SigntComp_1.SigntComp);
        // this.addComponent(GestureComp);
    }
    get model() {
        return this._model;
    }
    idle() {
        if (this._model.state != RoleModel_1.RoleState.Idle) {
            this._model.state = RoleModel_1.RoleState.Idle;
            this.animComp.play("Idle");
        }
    }
    hit() {
        super.hit();
    }
    onHurt(value) {
    }
    run() {
        if (this._model.state != RoleModel_1.RoleState.Run) {
            this._model.state = RoleModel_1.RoleState.Run;
            this.animComp.play("Move", { speed: this._model.speed });
        }
    }
    lockOnTarget() {
        this.findTarget();
        let playerPos = this.model.localPosition;
        let target = this.model.attackTarget;
        if (target) {
            let angle = MathUtil_1.getAngleByVector(target.model.localPosition.x - playerPos.x, target.model.localPosition.z - playerPos.z);
            // this.model.setRotation(this.model.localRotationEuler.x, angle, this.model.localRotationEuler.z)
            let action = new RotateToAction_1.default(0.1, new Laya.Vector3(this.model.localRotationEuler.x, angle, this.model.localRotationEuler.z));
            this.runAction(action);
        }
    }
    findTarget() {
        // 寻找目标 距离最近的目标
        let target = null;
        let targetDis = Number.MAX_VALUE;
        let playerPos = this.model.localPosition;
        const monsterList = GameManager_1.default.MonsterController.monsterList;
        for (let i = 0; i < monsterList.length; i++) {
            const monster = monsterList[i];
            let dx = Math.abs(monster.model.localPosition.x - playerPos.x);
            let dz = Math.abs(monster.model.localPosition.z - playerPos.z);
            if (dx <= this.model.attackRad && dz <= this.model.attackRad && monster.uuid != this.uuid && monster.model.enableHit()) {
                // 在攻击半径范围内
                let curDis = dx * dx + dz * dz;
                if (curDis < targetDis) {
                    target = monster;
                    targetDis = curDis;
                }
            }
        }
        this.model.attackTarget = target;
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = Player;

},{"../../core/BindEntityScript":10,"../../core/SceneManager":13,"../../core/action/RotateToAction":25,"../../core/util/EntityTypeDefine":35,"../../core/util/MathUtil":40,"../../core/util/ResLoader":41,"../../core/util/Util":42,"../GameManager":43,"../commponent/HpBarComp":52,"../commponent/PlayerCollisionComp":55,"../commponent/PlayerControlComp":56,"../commponent/RoleAnimComp":57,"../commponent/SigntComp":61,"../define/GameResDefine":74,"../model/PlayerModel":77,"../model/RoleModel":78,"../shader/ShadowMaterial":88,"./Role":82}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleEvent = void 0;
const BaseEntity_1 = require("../../core/BaseEntity");
const Logger_1 = require("../../core/util/Logger");
const RoleModel_1 = require("../model/RoleModel");
var RoleEvent;
(function (RoleEvent) {
    RoleEvent["State"] = "State";
})(RoleEvent = exports.RoleEvent || (exports.RoleEvent = {}));
class Role extends BaseEntity_1.default {
    constructor() {
        super();
    }
    lockOnTarget() {
    }
    run() {
        if (this._model.state != RoleModel_1.RoleState.Run) {
            this._model.state = RoleModel_1.RoleState.Run;
            this.animComp.play("Move", { speed: this._model.speed });
        }
    }
    idle() {
        if (this._model.state != RoleModel_1.RoleState.Idle) {
            this._model.state = RoleModel_1.RoleState.Idle;
            this.animComp.play("Idle");
        }
    }
    attack() {
        if (this._model.state != RoleModel_1.RoleState.Attak) {
            this._model.state = RoleModel_1.RoleState.Attak;
            this.animComp.play("Attack", { caller: this, callFunc: this.resetIdle, speed: this._model.attackSpeed });
        }
    }
    hit() {
        if (this._model.state == RoleModel_1.RoleState.Idle) {
            this._model.state = RoleModel_1.RoleState.Hit;
            this.animComp.play("Hit", { caller: this, callFunc: this.resetIdle });
        }
        else if (this._model.state == RoleModel_1.RoleState.Run) {
            this._model.state = RoleModel_1.RoleState.Hit;
            this.animComp.play("Hit", { caller: this, callFunc: this.resetRun });
        }
    }
    resetIdle() {
        this.idle();
    }
    resetRun() {
        this.run();
    }
    die() {
        if (this._model.state != RoleModel_1.RoleState.Die) {
            this._model.state = RoleModel_1.RoleState.Die;
            this.animComp.play("Die");
            Logger_1.log("Die");
        }
    }
    clearSkill() {
        for (let i = 0; i < this.skillGroup.length; i++) {
            let skill = this.skillGroup[i];
            skill.onDestory();
        }
        this.skillGroup = [];
    }
    updateHpBar() {
        this.hpBarComp.setValue(this._model.curHp, this._model.maxHp);
    }
    get model() {
        return this._model;
    }
    onHurt(value) {
        if (this._model.state == RoleModel_1.RoleState.Die) {
            return;
        }
        this._model.addHp(-1 * value);
        this.updateHpBar();
        if (this._model.curHp <= 0) {
            this.die();
        }
        else {
            this.hit();
        }
    }
    // 击中敌人
    onHit() {
    }
    addSkill(skill) {
        this.skillGroup.push(skill);
    }
    onDestory() {
        super.onDestory();
        this.clearSkill();
        this.model && this.model.onDestory();
        this._model = null;
        this.prefab.destroy();
    }
}
exports.default = Role;

},{"../../core/BaseEntity":5,"../../core/util/Logger":39,"../model/RoleModel":78}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseScene_1 = require("../../core/BaseScene");
const GameResDefine_1 = require("../define/GameResDefine");
const ResLoader_1 = require("../../core/util/ResLoader");
const GameManager_1 = require("../GameManager");
const ViewManager_1 = require("../../core/ViewManager");
const JoyStrickCtrl_1 = require("../view/JoyStrickCtrl");
const BattleBinder_1 = require("../../ui/Battle/BattleBinder");
const GameCamera_1 = require("../common/GameCamera");
const CollisionFilterDefine_1 = require("../define/CollisionFilterDefine");
const ShadowMaterial_1 = require("../shader/ShadowMaterial");
const EvoControlView_1 = require("../view/EvoControlView");
class GameScene extends BaseScene_1.default {
    constructor() {
        super(...arguments);
        this._exposureNumber = 0;
    }
    dependAssets() {
        let assets = [
            GameResDefine_1.default.SigntRes,
            GameResDefine_1.default.SkyBoxRes,
            GameResDefine_1.default.GameMap,
            GameResDefine_1.default.Battle_fuj,
            GameResDefine_1.default.Battle_atlas0,
            GameResDefine_1.default.MonsterRes,
            GameResDefine_1.default.HeroRes,
        ];
        return assets;
    }
    onLoad() {
        this._scene = new Laya.Scene3D();
        Laya.stage.addChild(this._scene);
        // 渲染静态变量初始化
        ShadowMaterial_1.default.__initDefine__();
        // 资源包
        fgui.UIPackage.addPackage("res/gui/Battle");
        BattleBinder_1.default.bindAll();
        // 进化控制面板
        this.evoControlView = ViewManager_1.default.addView(EvoControlView_1.default);
        //添加照相机
        this.gameCamera = new GameCamera_1.default();
        this._scene.addChild(this.gameCamera);
        // 场景雾
        this._scene.enableFog = true;
        this._scene.fogColor = new Laya.Vector3(0.7, 0.7, 0.7);
        this._scene.fogStart = 0;
        this._scene.fogRange = 100;
        // 摇杆
        ViewManager_1.default.addView(JoyStrickCtrl_1.default, new Laya.Vector2(Laya.stage.width / 2, Laya.stage.height - 200));
        let gamemap = ResLoader_1.default.getRes(GameResDefine_1.default.GameMap);
        this.bindWallCollisionFilter(gamemap);
        this._scene.addChild(gamemap);
        // 玩家
        GameManager_1.default.init();
        GameManager_1.default.start();
        GameManager_1.default.PlayerController.createPlayerAsyn();
        // 添加天空盒
        this.loadSkyBox();
        //添加方向光
        var directionLight = this._scene.addChild(new Laya.DirectionLight());
        directionLight.color = new Laya.Vector3(0.3, 0.3, 0.3);
        directionLight.transform.worldMatrix.setForward(new Laya.Vector3(-1, -1, 0));
        //添加自定义模型
        // var box: Laya.MeshSprite3D = this._scene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(1, 2, 1))) as Laya.MeshSprite3D;
        // box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false);
        // box.transform.translate(new Laya.Vector3(0,3,0));
        // var material: Laya.BlinnPhongMaterial = new Laya.BlinnPhongMaterial();
        // Laya.Texture2D.load("res/layabox.png", Laya.Handler.create(null, function(tex:Laya.Texture2D) {
        // 		material.albedoTexture = tex;
        // }));
        // box.meshRenderer.material = material;
        // box.addComponent(Laya.PhysicsCollider);
        // let rigid:Laya.Rigidbody3D = box.addComponent(Laya.Rigidbody3D);
        // //有刚体的shape要加在刚体上
        // rigid.colliderShape = new Laya.BoxColliderShape(1, 2, 1);
    }
    addPlayer(player) {
        this._scene.addChild(player.prefab);
    }
    bindWallCollisionFilter(gamemap) {
        let wallcol = gamemap.getChildByName("wallcol");
        let len = wallcol.numChildren;
        for (let i = 0; i < len; i++) {
            let wall = wallcol.getChildAt(i);
            wall.getComponent(Laya.PhysicsCollider).collisionGroup = CollisionFilterDefine_1.default.Wall;
        }
    }
    loadSkyBox() {
        let mat = ResLoader_1.default.getRes(GameResDefine_1.default.SkyBoxRes);
        let scene = this._scene;
        let skyRenderer = scene.skyRenderer;
        skyRenderer.mesh = Laya.SkyBox.instance;
        skyRenderer.material = mat;
        this.gameCamera.camera.clearFlag = Laya.BaseCamera.CLEARFLAG_SKY;
        Laya.timer.frameLoop(1, this, this.onFrameLoop);
    }
    onFrameLoop() {
        this.scene.skyRenderer.material.exposure = 0.3 * Math.sin(this._exposureNumber += 0.01) + 1;
        this.scene.skyRenderer.material.rotation += 0.1;
    }
}
exports.default = GameScene;

},{"../../core/BaseScene":8,"../../core/ViewManager":15,"../../core/util/ResLoader":41,"../../ui/Battle/BattleBinder":96,"../GameManager":43,"../common/GameCamera":47,"../define/CollisionFilterDefine":73,"../define/GameResDefine":74,"../shader/ShadowMaterial":88,"../view/EvoControlView":93,"../view/JoyStrickCtrl":94}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseLoadScene_1 = require("../../core/BaseLoadScene");
const ViewManager_1 = require("../../core/ViewManager");
const LoadingView_1 = require("../view/LoadingView");
const CommonBinder_1 = require("../../ui/Common/CommonBinder");
class LoadingScene extends BaseLoadScene_1.default {
    dependAssets() {
        let assets = [
            "res/gui/Common_atlas0.png",
            "res/gui/Common.bin"
        ];
        return assets;
    }
    onLoad() {
        this._scene = new Laya.Scene();
        Laya.stage.addChild(this._scene);
        fgui.UIPackage.addPackage("res/gui/Common");
        CommonBinder_1.default.bindAll();
        this._loadingView = ViewManager_1.default.addView(LoadingView_1.default);
        this._loadingView.view.displayObject.zOrder = ViewManager_1.ViewOrder.High;
    }
    show() {
        super.show();
        this._loadingView.show();
    }
    hide() {
        super.hide();
        this._loadingView.hide();
    }
    onProgress(value) {
        this._loadingView.setProgress(value);
    }
    onComplete() {
        this._loadingView.setProgress(1);
        super.onComplete();
        this.hide();
    }
    onDestory() {
        super.onDestory();
        this._loadingView.removeSelf();
    }
}
exports.default = LoadingScene;

},{"../../core/BaseLoadScene":6,"../../core/ViewManager":15,"../../ui/Common/CommonBinder":104,"../view/LoadingView":95}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiffuseFs = void 0;
exports.DiffuseFs = `
#ifdef HIGHPRECISION
precision highp float;
#else
precision mediump float;
#endif

#include "Lighting.glsl";

#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)
varying vec4 v_Color;
#endif

#ifdef ALBEDOTEXTURE
uniform sampler2D u_AlbedoTexture;
varying vec2 v_Texcoord0;
#endif

uniform vec4 u_AlbedoColor;

#ifdef ALPHATEST
uniform float u_AlphaTestValue;
#endif

#ifdef FOG
uniform float u_FogStart;
uniform float u_FogRange;
#ifdef ADDTIVEFOG
#else
    uniform vec3 u_FogColor;
#endif
#endif

#ifdef DIRECTIONLIGHT
	uniform DirectionLight u_DirectionLight;
#endif

varying vec3 v_Normal;

void main()
{
vec4 color =  u_AlbedoColor;
#ifdef ALBEDOTEXTURE
    color *= texture2D(u_AlbedoTexture, v_Texcoord0);
#endif
#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)
    color *= v_Color;
#endif

#ifdef ALPHATEST
    if(color.a < u_AlphaTestValue)
        discard;
#endif

gl_FragColor = color;

vec3 normal=normalize(v_Normal);
vec3 diffuse = (dot(-u_DirectionLight.direction, normal)*0.5+0.5)*u_DirectionLight.color;
gl_FragColor.rgb = gl_FragColor.rgb + diffuse;

#ifdef FOG

#endif

}

`;

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiffuseVs = void 0;
exports.DiffuseVs = `#include "Lighting.glsl";

attribute vec4 a_Position;

attribute vec2 a_Texcoord0;

attribute vec3 a_Normal;

#ifdef GPU_INSTANCE
	attribute mat4 a_MvpMatrix;
	attribute mat4 u_WorldMat;
#else
	uniform mat4 u_MvpMatrix;
	uniform mat4 u_WorldMat;
#endif

attribute vec4 a_Color;
varying vec4 v_Color;
varying vec2 v_Texcoord0;

#ifdef TILINGOFFSET
	uniform vec4 u_TilingOffset;
#endif

#ifdef BONE
	const int c_MaxBoneCount = 24;
	attribute vec4 a_BoneIndices;
	attribute vec4 a_BoneWeights;
	uniform mat4 u_Bones[c_MaxBoneCount];
#endif

varying vec3 v_Normal;

void main() {
	vec4 position;
	#ifdef BONE
		mat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;
		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;
		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;
		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;
		position=skinTransform*a_Position;
	#else
		position=a_Position;
	#endif
	#ifdef GPU_INSTANCE
		gl_Position = a_MvpMatrix * position;
	#else
		gl_Position = u_MvpMatrix * position;
	#endif

	#ifdef TILINGOFFSET
		v_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);
	#else
		v_Texcoord0=a_Texcoord0;
	#endif

	#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)
		v_Color = a_Color;
	#endif
	gl_Position=remapGLPositionZ(gl_Position);


	mat3 worldInvMat;
	#ifdef BONE
		worldInvMat=INVERSE_MAT(mat3(u_WorldMat*skinTransform));
	#else
		worldInvMat=INVERSE_MAT(mat3(u_WorldMat));
	#endif

	v_Normal = a_Normal * worldInvMat;
}`;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowFs = void 0;
exports.ShadowFs = `
#ifdef HIGHPRECISION
precision highp float;
#else
precision mediump float;
#endif

#include "Lighting.glsl";

#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)
varying vec4 v_Color;
#endif

#ifdef ALBEDOTEXTURE
uniform sampler2D u_AlbedoTexture;
varying vec2 v_Texcoord0;
#endif

uniform vec4 u_AlbedoColor;

#ifdef ALPHATEST
uniform float u_AlphaTestValue;
#endif

#ifdef FOG
uniform float u_FogStart;
uniform float u_FogRange;
#ifdef ADDTIVEFOG
#else
    uniform vec3 u_FogColor;
#endif
#endif

#ifdef DIRECTIONLIGHT
	uniform DirectionLight u_DirectionLight;
#endif

varying vec3 v_Normal;

void main()
{

gl_FragColor = vec4(0.2,0.2,0.2,0.8);

}

`;

},{}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DiffuseFs_1 = require("./DiffuseFs");
const DiffuseVs_1 = require("./DiffuseVs");
const ShadowVs_1 = require("./ShadowVs");
const ShadowFs_1 = require("./ShadowFs");
class ShadowMaterial extends Laya.Material {
    constructor() {
        super();
        this._albedoColor = new Laya.Vector4(1.0, 1.0, 1.0, 1.0);
        this._albedoIntensity = 1.0;
        this._enableVertexColor = false;
        this.initShader();
    }
    static __initDefine__() {
        ShadowMaterial.SHADERDEFINE_ALBEDOTEXTURE = Laya.Shader3D.getDefineByName("ALBEDOTEXTURE");
        ShadowMaterial.SHADERDEFINE_TILINGOFFSET = Laya.Shader3D.getDefineByName("TILINGOFFSET");
        ShadowMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
    }
    initShader() {
        let attributeMap = {
            'a_Position': Laya.VertexMesh.MESH_POSITION0,
            'a_Color': Laya.VertexMesh.MESH_COLOR0,
            'a_Texcoord0': Laya.VertexMesh.MESH_TEXTURECOORDINATE0,
            'a_BoneWeights': Laya.VertexMesh.MESH_BLENDWEIGHT0,
            'a_BoneIndices': Laya.VertexMesh.MESH_BLENDINDICES0,
            'a_MvpMatrix': Laya.VertexMesh.MESH_MVPMATRIX_ROW0,
            'a_Normal': Laya.VertexMesh.MESH_NORMAL0,
        };
        let uniformMap = {
            'u_Bones': Laya.Shader3D.PERIOD_CUSTOM,
            'u_AlbedoTexture': Laya.Shader3D.PERIOD_MATERIAL,
            'u_AlbedoColor': Laya.Shader3D.PERIOD_MATERIAL,
            'u_TilingOffset': Laya.Shader3D.PERIOD_MATERIAL,
            'u_AlphaTestValue': Laya.Shader3D.PERIOD_MATERIAL,
            'u_MvpMatrix': Laya.Shader3D.PERIOD_SPRITE,
            'u_WorldMat': Laya.Shader3D.PERIOD_SPRITE,
            'u_FogStart': Laya.Shader3D.PERIOD_SCENE,
            'u_FogRange': Laya.Shader3D.PERIOD_SCENE,
            'u_FogColor': Laya.Shader3D.PERIOD_SCENE,
            'u_DirectionLight.Direction': Laya.Shader3D.PERIOD_SCENE,
            'u_DirectionLight.Color': Laya.Shader3D.PERIOD_SCENE
        };
        let stateMap = {
            's_Cull': Laya.Shader3D.RENDER_STATE_CULL,
            's_Blend': Laya.Shader3D.RENDER_STATE_BLEND,
            's_BlendSrc': Laya.Shader3D.RENDER_STATE_BLEND_SRC,
            's_BlendDst': Laya.Shader3D.RENDER_STATE_BLEND_DST,
            's_DepthTest': Laya.Shader3D.RENDER_STATE_DEPTH_TEST,
            's_DepthWrite': Laya.Shader3D.RENDER_STATE_DEPTH_WRITE
        };
        let shader = Laya.Shader3D.add(ShadowMaterial.Name, null, null, true);
        let subShader = new Laya.SubShader(attributeMap, uniformMap);
        shader.addSubShader(subShader);
        subShader.addShaderPass(DiffuseVs_1.DiffuseVs, DiffuseFs_1.DiffuseFs, stateMap);
        subShader.addShaderPass(ShadowVs_1.ShadowVs, ShadowFs_1.ShadowFs, stateMap);
        this.setShaderName(ShadowMaterial.Name);
        this._shaderValues.setVector(ShadowMaterial.ALBEDOCOLOR, new Laya.Vector4(1.0, 1.0, 1.0, 1.0));
        this.renderMode = ShadowMaterial.RENDERMODE_ADDTIVE;
    }
    /**
     * @internal
     */
    get _ColorR() {
        return this._albedoColor.x;
    }
    set _ColorR(value) {
        this._albedoColor.x = value;
        this.albedoColor = this._albedoColor;
    }
    /**
     * @internal
     */
    get _ColorG() {
        return this._albedoColor.y;
    }
    set _ColorG(value) {
        this._albedoColor.y = value;
        this.albedoColor = this._albedoColor;
    }
    /**
     * @internal
     */
    get _ColorB() {
        return this._albedoColor.z;
    }
    set _ColorB(value) {
        this._albedoColor.z = value;
        this.albedoColor = this._albedoColor;
    }
    /**
     * @internal
     */
    get _ColorA() {
        return this._albedoColor.w;
    }
    set _ColorA(value) {
        this._albedoColor.w = value;
        this.albedoColor = this._albedoColor;
    }
    /**
     * @internal
     */
    get _AlbedoIntensity() {
        return this._albedoIntensity;
    }
    set _AlbedoIntensity(value) {
        if (this._albedoIntensity !== value) {
            var finalAlbedo = this._shaderValues.getVector(ShadowMaterial.ALBEDOCOLOR);
            Laya.Vector4.scale(this._albedoColor, value, finalAlbedo);
            this._albedoIntensity = value;
            this._shaderValues.setVector(ShadowMaterial.ALBEDOCOLOR, finalAlbedo);
        }
    }
    /**
     * @internal
     */
    get _MainTex_STX() {
        return this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET).x;
    }
    set _MainTex_STX(x) {
        var tilOff = this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET);
        tilOff.x = x;
        this.tilingOffset = tilOff;
    }
    /**
     * @internal
     */
    get _MainTex_STY() {
        return this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET).y;
    }
    set _MainTex_STY(y) {
        var tilOff = this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET);
        tilOff.y = y;
        this.tilingOffset = tilOff;
    }
    /**
     * @internal
     */
    get _MainTex_STZ() {
        return this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET).z;
    }
    set _MainTex_STZ(z) {
        var tilOff = this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET);
        tilOff.z = z;
        this.tilingOffset = tilOff;
    }
    /**
     * @internal
     */
    get _MainTex_STW() {
        return this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET).w;
    }
    set _MainTex_STW(w) {
        var tilOff = this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET);
        tilOff.w = w;
        this.tilingOffset = tilOff;
    }
    /**
     * @internal
     */
    get _Cutoff() {
        return this.alphaTestValue;
    }
    set _Cutoff(value) {
        this.alphaTestValue = value;
    }
    /**
     * 反照率颜色R分量。
     */
    get albedoColorR() {
        return this._ColorR;
    }
    set albedoColorR(value) {
        this._ColorR = value;
    }
    /**
     * 反照率颜色G分量。
     */
    get albedoColorG() {
        return this._ColorG;
    }
    set albedoColorG(value) {
        this._ColorG = value;
    }
    /**
     * 反照率颜色B分量。
     */
    get albedoColorB() {
        return this._ColorB;
    }
    set albedoColorB(value) {
        this._ColorB = value;
    }
    /**
     * 反照率颜色Z分量。
     */
    get albedoColorA() {
        return this._ColorA;
    }
    set albedoColorA(value) {
        this._ColorA = value;
    }
    /**
     * 反照率颜色。
     */
    get albedoColor() {
        return this._albedoColor;
    }
    set albedoColor(value) {
        var finalAlbedo = this._shaderValues.getVector(ShadowMaterial.ALBEDOCOLOR);
        Laya.Vector4.scale(value, this._albedoIntensity, finalAlbedo);
        this._albedoColor = value;
        this._shaderValues.setVector(ShadowMaterial.ALBEDOCOLOR, finalAlbedo);
    }
    /**
     * 反照率强度。
     */
    get albedoIntensity() {
        return this._albedoIntensity;
    }
    set albedoIntensity(value) {
        this._AlbedoIntensity = value;
    }
    /**
     * 反照率贴图。
     */
    get albedoTexture() {
        return this._shaderValues.getTexture(ShadowMaterial.ALBEDOTEXTURE);
    }
    set albedoTexture(value) {
        if (value)
            this._shaderValues.addDefine(ShadowMaterial.SHADERDEFINE_ALBEDOTEXTURE);
        else
            this._shaderValues.removeDefine(ShadowMaterial.SHADERDEFINE_ALBEDOTEXTURE);
        this._shaderValues.setTexture(ShadowMaterial.ALBEDOTEXTURE, value);
    }
    /**
     * 纹理平铺和偏移X分量。
     */
    get tilingOffsetX() {
        return this._MainTex_STX;
    }
    set tilingOffsetX(x) {
        this._MainTex_STX = x;
    }
    /**
     * 纹理平铺和偏移Y分量。
     */
    get tilingOffsetY() {
        return this._MainTex_STY;
    }
    set tilingOffsetY(y) {
        this._MainTex_STY = y;
    }
    /**
     * 纹理平铺和偏移Z分量。
     */
    get tilingOffsetZ() {
        return this._MainTex_STZ;
    }
    set tilingOffsetZ(z) {
        this._MainTex_STZ = z;
    }
    /**
     * 纹理平铺和偏移W分量。
     */
    get tilingOffsetW() {
        return this._MainTex_STW;
    }
    set tilingOffsetW(w) {
        this._MainTex_STW = w;
    }
    /**
     * 纹理平铺和偏移。
     */
    get tilingOffset() {
        return this._shaderValues.getVector(ShadowMaterial.TILINGOFFSET);
    }
    set tilingOffset(value) {
        if (value) {
            if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                this._shaderValues.addDefine(ShadowMaterial.SHADERDEFINE_TILINGOFFSET);
            else
                this._shaderValues.removeDefine(ShadowMaterial.SHADERDEFINE_TILINGOFFSET);
        }
        else {
            this._shaderValues.removeDefine(ShadowMaterial.SHADERDEFINE_TILINGOFFSET);
        }
        this._shaderValues.setVector(ShadowMaterial.TILINGOFFSET, value);
    }
    /**
     * 是否支持顶点色。
     */
    get enableVertexColor() {
        return this._enableVertexColor;
    }
    set enableVertexColor(value) {
        this._enableVertexColor = value;
        if (value)
            this._shaderValues.addDefine(ShadowMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        else
            this._shaderValues.removeDefine(ShadowMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
    }
    /**
     * 渲染模式。
     */
    set renderMode(value) {
        switch (value) {
            case ShadowMaterial.RENDERMODE_OPAQUE:
                this.alphaTest = false;
                this.renderQueue = Laya.Material.RENDERQUEUE_OPAQUE;
                this.depthWrite = true;
                this.cull = Laya.RenderState.CULL_BACK;
                this.blend = Laya.RenderState.BLEND_DISABLE;
                this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                break;
            case ShadowMaterial.RENDERMODE_CUTOUT:
                this.renderQueue = Laya.Material.RENDERQUEUE_ALPHATEST;
                this.alphaTest = true;
                this.depthWrite = true;
                this.cull = Laya.RenderState.CULL_BACK;
                this.blend = Laya.RenderState.BLEND_DISABLE;
                this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                break;
            case ShadowMaterial.RENDERMODE_TRANSPARENT:
                this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                this.alphaTest = false;
                this.depthWrite = false;
                this.cull = Laya.RenderState.CULL_BACK;
                this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                break;
            case ShadowMaterial.RENDERMODE_ADDTIVE:
                this.renderQueue = Laya.BaseMaterial.RENDERQUEUE_TRANSPARENT;
                this.alphaTest = false;
                this.depthWrite = true;
                this.cull = Laya.RenderState.CULL_BACK;
                this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                break;
            default:
                throw new Error("ShadowMaterial : renderMode value error.");
        }
    }
    /**
     * 是否写入深度。
     */
    get depthWrite() {
        return this._shaderValues.getBool(ShadowMaterial.DEPTH_WRITE);
    }
    set depthWrite(value) {
        this._shaderValues.setBool(ShadowMaterial.DEPTH_WRITE, value);
    }
    /**
     * 剔除方式。
     */
    get cull() {
        return this._shaderValues.getInt(ShadowMaterial.CULL);
    }
    set cull(value) {
        this._shaderValues.setInt(ShadowMaterial.CULL, value);
    }
    /**
     * 混合方式。
     */
    get blend() {
        return this._shaderValues.getInt(ShadowMaterial.BLEND);
    }
    set blend(value) {
        this._shaderValues.setInt(ShadowMaterial.BLEND, value);
    }
    /**
     * 混合源。
     */
    get blendSrc() {
        return this._shaderValues.getInt(ShadowMaterial.BLEND_SRC);
    }
    set blendSrc(value) {
        this._shaderValues.setInt(ShadowMaterial.BLEND_SRC, value);
    }
    /**
     * 混合目标。
     */
    get blendDst() {
        return this._shaderValues.getInt(ShadowMaterial.BLEND_DST);
    }
    set blendDst(value) {
        this._shaderValues.setInt(ShadowMaterial.BLEND_DST, value);
    }
    /**
     * 深度测试方式。
     */
    get depthTest() {
        return this._shaderValues.getInt(ShadowMaterial.DEPTH_TEST);
    }
    set depthTest(value) {
        this._shaderValues.setInt(ShadowMaterial.DEPTH_TEST, value);
    }
}
exports.default = ShadowMaterial;
ShadowMaterial.Name = "ShadowShader";
/**渲染状态_不透明。*/
ShadowMaterial.RENDERMODE_OPAQUE = 0;
/**渲染状态_阿尔法测试。*/
ShadowMaterial.RENDERMODE_CUTOUT = 1;
/**渲染状态__透明混合。*/
ShadowMaterial.RENDERMODE_TRANSPARENT = 2;
/**渲染状态__加色法混合。*/
ShadowMaterial.RENDERMODE_ADDTIVE = 3;
ShadowMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_AlbedoTexture");
ShadowMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_AlbedoColor");
ShadowMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
ShadowMaterial.CULL = Laya.Shader3D.propertyNameToID("s_Cull");
ShadowMaterial.BLEND = Laya.Shader3D.propertyNameToID("s_Blend");
ShadowMaterial.BLEND_SRC = Laya.Shader3D.propertyNameToID("s_BlendSrc");
ShadowMaterial.BLEND_DST = Laya.Shader3D.propertyNameToID("s_BlendDst");
ShadowMaterial.DEPTH_TEST = Laya.Shader3D.propertyNameToID("s_DepthTest");
ShadowMaterial.DEPTH_WRITE = Laya.Shader3D.propertyNameToID("s_DepthWrite");

},{"./DiffuseFs":85,"./DiffuseVs":86,"./ShadowFs":87,"./ShadowVs":89}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowVs = void 0;
exports.ShadowVs = `#include "Lighting.glsl";

attribute vec4 a_Position;

attribute vec2 a_Texcoord0;

attribute vec3 a_Normal;

#ifdef GPU_INSTANCE
	attribute mat4 a_MvpMatrix;
#else
	uniform mat4 u_MvpMatrix;
#endif

uniform mat4 u_WorldMat;

attribute vec4 a_Color;
varying vec4 v_Color;
varying vec2 v_Texcoord0;

#ifdef TILINGOFFSET
	uniform vec4 u_TilingOffset;
#endif

#ifdef BONE
	const int c_MaxBoneCount = 24;
	attribute vec4 a_BoneIndices;
	attribute vec4 a_BoneWeights;
	uniform mat4 u_Bones[c_MaxBoneCount];
#endif

varying vec3 v_Normal;

void main() {
	vec4 position;

	vec4 new_Position; 

	#ifdef BONE
		mat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;
		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;
		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;
		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;
		position=skinTransform*a_Position;
		new_Position = vec4(position.x+position.y*0.2, position.y*0.2, position.z, position.w);
	#else
		new_Position = vec4(a_Position.x+a_Position.y*0.5, a_Position.y*0.5, a_Position.z, a_Position.w);
	#endif
	#ifdef GPU_INSTANCE
		gl_Position = a_MvpMatrix * new_Position;
	#else
		gl_Position = u_MvpMatrix * new_Position;
	#endif

	#ifdef TILINGOFFSET
		v_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);
	#else
		v_Texcoord0=a_Texcoord0;
	#endif

	#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)
		v_Color = a_Color;
	#endif
	gl_Position=remapGLPositionZ(gl_Position);


	mat3 worldInvMat;
	#ifdef BONE
		worldInvMat=INVERSE_MAT(mat3(u_WorldMat*skinTransform));
	#else
		worldInvMat=INVERSE_MAT(mat3(u_WorldMat));
	#endif

	v_Normal = a_Normal * worldInvMat;
}`;

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseComponent_1 = require("../../core/BaseComponent");
const LogicScheduler_1 = require("../../core/LogicScheduler");
const RoleModel_1 = require("../model/RoleModel");
const Role_1 = require("../prefab/Role");
class NormalAttackTrigger extends BaseComponent_1.default {
    constructor() {
        super();
        this._state = false;
        this._preAttackTime = 0;
        this.updateComp = true;
    }
    onLoad() {
        super.onLoad();
        this.skill = this.entity;
        this.skill.owner.on(Role_1.RoleEvent.State, this, this.stateChange);
        this._roleModel = this.skill.owner.model;
    }
    stateChange(state) {
        if (state != RoleModel_1.RoleState.Attak) {
            this.skill.unexcuteShoot();
        }
    }
    init() {
    }
    // 攻击
    attack() {
        let playmodel = this.skill.owner.model;
        if (playmodel.enableAttack()) {
            this._preAttackTime = Laya.timer.currTimer;
            this.skill.excuteEffect();
        }
    }
    update() {
        if (this._roleModel.state == RoleModel_1.RoleState.Idle) {
            let delayTime = this._roleModel.attackSpeed * 1000;
            if (Laya.timer.currTimer - this._preAttackTime >= delayTime) {
                this.attack();
            }
        }
    }
    onDestory() {
        LogicScheduler_1.default.clearAll(this);
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.default = NormalAttackTrigger;

},{"../../core/BaseComponent":3,"../../core/LogicScheduler":12,"../model/RoleModel":78,"../prefab/Role":82}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseComponent_1 = require("../../core/BaseComponent");
const GameManager_1 = require("../GameManager");
const Bullet_1 = require("../prefab/Bullet");
class NormallAttackEffect extends BaseComponent_1.default {
    constructor() {
        super();
    }
    excute(pos, rotate) {
        let bullet = GameManager_1.default.BulletController.getBullet(Bullet_1.BulletType.Normal);
        let skillUser = this.entity.owner;
        bullet.setUser(skillUser);
        bullet.shoot(pos, rotate);
    }
    unexcute() {
    }
    onDestory() {
        super.onDestory();
    }
    onEnable() {
        super.onEnable();
    }
    onDisable() {
        super.onDisable();
    }
}
exports.default = NormallAttackEffect;

},{"../../core/BaseComponent":3,"../GameManager":43,"../prefab/Bullet":79}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseEntity_1 = require("../../core/BaseEntity");
const NormalAttackTrigger_1 = require("./NormalAttackTrigger");
const NormallAttackEffect_1 = require("./NormallAttackEffect");
const LogicScheduler_1 = require("../../core/LogicScheduler");
class NormallAttackSkill extends BaseEntity_1.default {
    constructor() {
        super();
    }
    init(owner) {
        this.owner = owner;
        this.skillTrigger = this.addComponent(NormalAttackTrigger_1.default);
        this.skillEffect = this.addComponent(NormallAttackEffect_1.default);
        this.skillTrigger.init();
    }
    excuteEffect() {
        this.owner.lockOnTarget();
        if (this.owner.model.attackTarget != null) {
            this.owner.attack();
            LogicScheduler_1.default.once(this.owner.model.attackTrigger * this.owner.model.attackSpeed, this, this.excuteShoot);
        }
    }
    unexcuteShoot() {
        LogicScheduler_1.default.clear(this, this.excuteShoot);
    }
    excuteShoot() {
        let playmodel = this.owner.model;
        this.skillEffect.excute(playmodel.localPosition, playmodel.localRotationEuler);
    }
    unexcuteEffect() {
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = NormallAttackSkill;

},{"../../core/BaseEntity":5,"../../core/LogicScheduler":12,"./NormalAttackTrigger":90,"./NormallAttackEffect":91}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseView_1 = require("../../core/BaseView");
const UI_EvoControlPanel_1 = require("../../ui/Battle/UI_EvoControlPanel");
const ViewManager_1 = require("../../core/ViewManager");
const LogicScheduler_1 = require("../../core/LogicScheduler");
const EventManager_1 = require("../../core/EventManager");
const GameStageController_1 = require("../controller/GameStageController");
const I18nUtil_1 = require("../../core/util/I18nUtil");
const AIGeneticController_1 = require("../controller/AIGeneticController");
const GameCacheData_1 = require("../common/GameCacheData");
const MonsterAIComp_1 = require("../commponent/MonsterAIComp");
const Util_1 = require("../../core/util/Util");
class EvoControlView extends BaseView_1.default {
    constructor() {
        super();
        this.isShow = true;
        this.peopleItemList = [];
        this.view = UI_EvoControlPanel_1.default.createInstance();
        this.view.displayObject.zOrder = ViewManager_1.ViewOrder.High;
        EventManager_1.default.on(AIGeneticController_1.AIGeneticComp.CurStep, this, this.updateStepProgress);
        EventManager_1.default.on(AIGeneticController_1.AIGeneticComp.Evolve, this, this.updateEvoCount);
        EventManager_1.default.on(GameStageController_1.StageCmd.CurScale, this, this.updateScale);
        EventManager_1.default.on(MonsterAIComp_1.MonsterAIEvent.ThinkData, this, this.updatePeopleItem);
    }
    onLoad() {
        this.view.width = Laya.stage.width;
        this.view.m_pauseBtn.onClick(this, this.onClickPause);
        this.view.m_addScale.onClick(this, this.onClickAddScale);
        this.view.m_subScale.onClick(this, this.onClickSubScale);
        this.view.m_sliderBtn.onClick(this, this.onClickSliderBtn);
        this.view.m_fire.onClick(this, this.onClickFire);
        this.view.m_evoProgress.max = GameCacheData_1.default.Ins.evolutionCycle;
        this.peopleItemList.push(this.view.m_item1);
        this.peopleItemList.push(this.view.m_item2);
        this.peopleItemList.push(this.view.m_item3);
        this.peopleItemList.push(this.view.m_item4);
        this.peopleItemList.push(this.view.m_item5);
        this.view.displayObject.y = Util_1.getTopPadding();
    }
    onClickSliderBtn() {
        if (this.isShow) {
            this.view.displayObject.y -= this.view.displayObject.height;
            this.isShow = false;
        }
        else {
            this.view.displayObject.y += this.view.displayObject.height;
            this.isShow = true;
        }
    }
    onClickFire() {
        EventManager_1.default.emit(GameStageController_1.StageCmd.PlayerFight);
    }
    updatePeopleItem(index, input, ouput, name) {
        let peopleItem = this.peopleItemList[index];
        peopleItem.m_input1.text = input[0] + "";
        peopleItem.m_input2.text = input[1] + "";
        peopleItem.m_input3.text = input[2].toFixed(2);
        peopleItem.m_input4.text = input[3].toFixed(2);
        peopleItem.m_input5.text = input[4].toFixed(2);
        peopleItem.m_input6.text = input[5].toFixed(2);
        peopleItem.m_output.text = ouput + "";
        peopleItem.m_name.text = name;
    }
    updateStepProgress(curStep) {
        this.view.m_evoProgress.value = curStep;
    }
    updateEvoCount() {
        this.view.m_evoCount.text = GameCacheData_1.default.Ins.evolutionCount + "";
    }
    updateScale(curScale) {
        this.view.m_curScale.text = curScale.toFixed(1) + "";
    }
    onClickPause() {
        if (LogicScheduler_1.default.Ins.isPause) {
            this.view.m_pauseBtn.title = I18nUtil_1.i18n("暂停");
            EventManager_1.default.emit(GameStageController_1.StageCmd.Resume);
        }
        else {
            this.view.m_pauseBtn.title = I18nUtil_1.i18n("恢复");
            EventManager_1.default.emit(GameStageController_1.StageCmd.Pause);
        }
    }
    onClickAddScale() {
        EventManager_1.default.emit(GameStageController_1.StageCmd.AddScale);
    }
    onClickSubScale() {
        EventManager_1.default.emit(GameStageController_1.StageCmd.SubScale);
    }
    onDestory() {
        EventManager_1.default.offAll(this);
    }
}
exports.default = EvoControlView;

},{"../../core/BaseView":9,"../../core/EventManager":11,"../../core/LogicScheduler":12,"../../core/ViewManager":15,"../../core/util/I18nUtil":37,"../../core/util/Util":42,"../../ui/Battle/UI_EvoControlPanel":97,"../common/GameCacheData":46,"../commponent/MonsterAIComp":53,"../controller/AIGeneticController":67,"../controller/GameStageController":69}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dir = exports.JoyCmd = void 0;
const BaseView_1 = require("../../core/BaseView");
const UI_JoyStick_1 = require("../../ui/Battle/UI_JoyStick");
const EventManager_1 = require("../../core/EventManager");
const ViewManager_1 = require("../../core/ViewManager");
var TouchType;
(function (TouchType) {
    TouchType[TouchType["DEFAULT"] = 0] = "DEFAULT";
    TouchType[TouchType["FOLLOW"] = 1] = "FOLLOW";
})(TouchType || (TouchType = {}));
var DirectionType;
(function (DirectionType) {
    DirectionType[DirectionType["FOUR"] = 0] = "FOUR";
    DirectionType[DirectionType["EIGHT"] = 1] = "EIGHT";
    DirectionType[DirectionType["ALL"] = 2] = "ALL";
})(DirectionType || (DirectionType = {}));
var JoyCmd;
(function (JoyCmd) {
    JoyCmd["STOP"] = "STOP";
    JoyCmd["MOVE"] = "MOVE";
})(JoyCmd = exports.JoyCmd || (exports.JoyCmd = {}));
var Dir;
(function (Dir) {
    Dir[Dir["Center"] = null] = "Center";
    Dir[Dir["Up"] = 90] = "Up";
    Dir[Dir["Down"] = 270] = "Down";
    Dir[Dir["Left"] = 180] = "Left";
    Dir[Dir["Right"] = 0] = "Right";
    Dir[Dir["LeftUp"] = 135] = "LeftUp";
    Dir[Dir["LeftDown"] = 225] = "LeftDown";
    Dir[Dir["RightUp"] = 45] = "RightUp";
    Dir[Dir["RightDown"] = 315] = "RightDown"; // 右下 
})(Dir = exports.Dir || (exports.Dir = {}));
class JoyStrickCtrl extends BaseView_1.default {
    constructor() {
        super();
        // 中心点偏移
        this.origin = 0;
        // 摇杆半径
        this.radius = 45;
        // 操作类型
        this.touchType = TouchType.DEFAULT;
        // 方向类型 
        this.directionType = DirectionType.ALL;
        // 透明度
        this.defaultOpacity = 1;
        //当前角度
        this.curAngle = 0;
        //当前摇杆偏移量
        this.curDeviation = 0;
        //当前距离
        this.distance = 0;
        // 触发事件标志
        this.isTrigger = false;
        // 角度阈值(敏感度)
        this.thresholdAngle = 1;
        this._touchId = -1;
        this.view = UI_JoyStick_1.default.createInstance();
        this.view.scaleX = 2;
        this.view.scaleY = 2;
        this.view.displayObject.zOrder = ViewManager_1.ViewOrder.Middle;
    }
    onLoad(pos) {
        this.view.x = pos.x;
        this.view.y = pos.y;
        this.view.alpha = this.defaultOpacity;
        this.initPos = new Laya.Vector2(this.view.x, this.view.y);
        this.origin = this.view.m_bg.width * this.view.m_bg.scaleX / 2;
        if (this.radius === 0) {
            this.radius = this.origin;
        }
        this.registerTouch();
    }
    registerTouch() {
        Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.onTouchStart);
        Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.onTouchMove);
        Laya.stage.on(Laya.Event.MOUSE_UP, this, this.onTouchEnd);
        Laya.stage.on(Laya.Event.MOUSE_OUT, this, this.onTouchCancel);
    }
    onTouchStart(event) {
        if (this._touchId != -1) {
            return;
        }
        this._touchId = event.touchId;
        //如果触摸类型为FOLLOW，则摇控杆的位置为触摸位置,触摸开始时候现形
        if (this.touchType == TouchType.FOLLOW) {
            this.view.setXY(event.stageX, event.stageY);
            this.isTrigger = true;
            return;
        }
        else {
            // 把触摸点坐标转换为相对与目标的模型坐标
            const touchPos = this.view.globalToLocal(event.stageX, event.stageY);
            //点与圆心的距离
            const distance = Math.sqrt(touchPos.x * touchPos.x + touchPos.y * touchPos.y);
            //如果点与圆心距离小于圆的半径,且大于操作阈值,触控成功
            if (distance < this.origin) {
                this.view.alpha = 1;
                this.setStickBarPos(touchPos.x, touchPos.y);
                this.updateAngle(touchPos.x, touchPos.y);
                this.isTrigger = true;
                return;
            }
        }
        this.isTrigger = false;
    }
    onTouchMove(event) {
        if (this._touchId == -1 || event.touchId != this._touchId) {
            return;
        }
        if (!this.isTrigger) {
            return;
        }
        const touchPos = this.view.globalToLocal(event.stageX, event.stageY);
        const distance = Math.sqrt(touchPos.x * touchPos.x + touchPos.y * touchPos.y);
        if (this.radius >= distance) {
            //如果点与圆心距离小于圆的半径,控杆跟随触摸点
            this.setStickBarPos(touchPos.x, touchPos.y);
        }
        else {
            let angle = this.calcuRadian(touchPos.x, touchPos.y);
            let x = Math.cos(angle) * this.radius;
            let y = Math.sin(angle) * this.radius;
            if (touchPos.y < 0) {
                // 在三四象限的时候,y要调整
                y *= -1;
            }
            this.setStickBarPos(x, y);
        }
        this.view.alpha = 1;
        // 更新角度
        this.updateAngle(touchPos.x, touchPos.y);
    }
    onTouchEnd(event) {
        if (this._touchId == -1 || event.touchId != this._touchId) {
            return;
        }
        this._touchId = -1;
        if (!this.isTrigger) {
            return;
        }
        this.isTrigger = false;
        this.resetStick();
    }
    onTouchCancel(event) {
        if (this._touchId == -1 || event.touchId != this._touchId) {
            return;
        }
        this._touchId = -1;
        if (!this.isTrigger) {
            return;
        }
        this.isTrigger = false;
        this.resetStick();
    }
    // 更新方向
    updateAngle(x, y) {
        this.curAngle = this.calcuRadian(x, y) * 180 / Math.PI;
        this.curDeviation = Math.sqrt(x * x + y * y);
        if (x > 0 && y < 0 || x < 0 && y < 0) {
            this.curAngle = 360 - this.curAngle;
        }
        else if (x < 0 && y == 0) {
            this.curAngle = 180;
        }
        else if (x > 0 && y == 0) {
            this.curAngle = 0;
        }
        else if (x == 0 && y > 0) {
            this.curAngle = 90;
        }
        else if (x == 0 && y < 0) {
            this.curAngle = 270;
        }
        this.formatAngle();
    }
    formatAngle() {
        switch (this.directionType) {
            case DirectionType.FOUR:
                this.curAngle = this.fourDirections();
                break;
            case DirectionType.EIGHT:
                this.curAngle = this.eightDirections();
                break;
            case DirectionType.ALL:
                this.curAngle = this.curAngle;
                break;
            default:
                this.curAngle = null;
                break;
        }
        this.emitAngle();
    }
    // 格式化方向(四方向)
    fourDirections() {
        if (this.curAngle >= 45 && this.curAngle <= 135) {
            return Dir.Up;
        }
        else if (this.curAngle >= 225 && this.curAngle <= 315) {
            return Dir.Down;
        }
        else if (this.curAngle <= 225 && this.curAngle >= 180 || this.curAngle >= 135 && this.curAngle <= 180) {
            return Dir.Left;
        }
        else if (this.curAngle <= 360 && this.curAngle >= 315 || this.curAngle >= 0 && this.curAngle <= 45) {
            return Dir.Right;
        }
    }
    // 格式化方向(八方向)
    eightDirections() {
        if (this.curAngle >= 67.5 && this.curAngle <= 112.5) {
            return Dir.Up;
        }
        else if (this.curAngle >= 247.5 && this.curAngle <= 292.5) {
            return Dir.Down;
        }
        else if (this.curAngle <= 202.5 && this.curAngle >= 180 || this.curAngle >= 157.5 && this.curAngle <= 180) {
            return Dir.Left;
        }
        else if (this.curAngle <= 360 && this.curAngle >= 337.5 || this.curAngle >= 0 && this.curAngle <= 22.5) {
            return Dir.Right;
        }
        else if (this.curAngle >= 112.5 && this.curAngle <= 157.5) {
            return Dir.LeftUp;
        }
        else if (this.curAngle >= 22.5 && this.curAngle <= 67.5) {
            return Dir.RightUp;
        }
        else if (this.curAngle >= 202.5 && this.curAngle <= 247.5) {
            return Dir.LeftDown;
        }
        else if (this.curAngle >= 292.5 && this.curAngle <= 337.5) {
            return Dir.RightDown;
        }
    }
    // 计算弧度
    calcuRadian(x, y) {
        const z = x * x + y * y;
        if (z === 0) {
            return 0;
        }
        else {
            return Math.acos(x / Math.sqrt(z));
        }
    }
    resetStick() {
        this.view.alpha = this.defaultOpacity;
        //如果触摸类型为FOLLOW，离开触摸后隐藏
        if (this.touchType == TouchType.FOLLOW) {
            this.view.setXY(this.initPos.x, this.initPos.y);
        }
        this.setStickBarPos(0, 0);
        this.curAngle = null;
        this.curDeviation = 0;
        this.emitAngle();
    }
    setStickBarPos(x, y) {
        this.view.m_stickBar.setXY(x + this.origin, y + this.origin);
        this.view.m_light.setXY(x + this.origin, y + this.origin);
    }
    // 推送更新方向通知
    emitAngle() {
        if (this.curAngle == null) {
            // 取消操作通知
            EventManager_1.default.emit(JoyCmd.STOP);
        }
        else {
            if ((this.preAngle == null) || Math.abs(this.preAngle - this.curAngle) > this.thresholdAngle) {
                // 大于敏感值时发送,移动通知
                EventManager_1.default.emit(JoyCmd.MOVE, this.curAngle, this.curDeviation);
            }
        }
        this.preAngle = this.curAngle;
    }
    onDestory() {
        super.onDestory();
    }
}
exports.default = JoyStrickCtrl;

},{"../../core/BaseView":9,"../../core/EventManager":11,"../../core/ViewManager":15,"../../ui/Battle/UI_JoyStick":99}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseView_1 = require("../../core/BaseView");
const UI_Loading_1 = require("../../ui/Common/UI_Loading");
class LoadingView extends BaseView_1.default {
    constructor() {
        super();
        this.view = UI_Loading_1.default.createInstance();
    }
    onLoad() {
        this.view.width = Laya.stage.width;
        this.view.height = Laya.stage.height;
        this.view.m_progressBar.max = 1;
    }
    setProgress(value) {
        this.view.m_progressBar.value = value;
    }
}
exports.default = LoadingView;

},{"../../core/BaseView":9,"../../ui/Common/UI_Loading":105}],96:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
const UI_HpBar_1 = require("./UI_HpBar");
const UI_sliderButton_1 = require("./UI_sliderButton");
const UI_EvoControlPanel_1 = require("./UI_EvoControlPanel");
const UI_TimeProgressBar_1 = require("./UI_TimeProgressBar");
const UI_pushButton_1 = require("./UI_pushButton");
const UI_PeopleItem_1 = require("./UI_PeopleItem");
const UI_JoyStick_1 = require("./UI_JoyStick");
class BattleBinder {
    static bindAll() {
        fgui.UIObjectFactory.setExtension(UI_HpBar_1.default.URL, UI_HpBar_1.default);
        fgui.UIObjectFactory.setExtension(UI_sliderButton_1.default.URL, UI_sliderButton_1.default);
        fgui.UIObjectFactory.setExtension(UI_EvoControlPanel_1.default.URL, UI_EvoControlPanel_1.default);
        fgui.UIObjectFactory.setExtension(UI_TimeProgressBar_1.default.URL, UI_TimeProgressBar_1.default);
        fgui.UIObjectFactory.setExtension(UI_pushButton_1.default.URL, UI_pushButton_1.default);
        fgui.UIObjectFactory.setExtension(UI_PeopleItem_1.default.URL, UI_PeopleItem_1.default);
        fgui.UIObjectFactory.setExtension(UI_JoyStick_1.default.URL, UI_JoyStick_1.default);
    }
}
exports.default = BattleBinder;

},{"./UI_EvoControlPanel":97,"./UI_HpBar":98,"./UI_JoyStick":99,"./UI_PeopleItem":100,"./UI_TimeProgressBar":101,"./UI_pushButton":102,"./UI_sliderButton":103}],97:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_EvoControlPanel extends fgui.GComponent {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "EvoControlPanel"));
    }
    onConstruct() {
        this.m_n10 = (this.getChild("n10"));
        this.m_evoProgress = (this.getChild("evoProgress"));
        this.m_n3 = (this.getChild("n3"));
        this.m_n5 = (this.getChild("n5"));
        this.m_evoCount = (this.getChild("evoCount"));
        this.m_n8 = (this.getChild("n8"));
        this.m_pauseBtn = (this.getChild("pauseBtn"));
        this.m_addScale = (this.getChild("addScale"));
        this.m_subScale = (this.getChild("subScale"));
        this.m_n14 = (this.getChild("n14"));
        this.m_curScale = (this.getChild("curScale"));
        this.m_sliderBtn = (this.getChild("sliderBtn"));
        this.m_item1 = (this.getChild("item1"));
        this.m_item2 = (this.getChild("item2"));
        this.m_item3 = (this.getChild("item3"));
        this.m_item4 = (this.getChild("item4"));
        this.m_item5 = (this.getChild("item5"));
        this.m_fire = (this.getChild("fire"));
    }
}
exports.default = UI_EvoControlPanel;
UI_EvoControlPanel.URL = "ui://u9h77rfdqbl5s";

},{}],98:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_HpBar extends fgui.GComponent {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "HpBar"));
    }
    onConstruct() {
        this.m_n0 = (this.getChild("n0"));
        this.m_reduce = (this.getChild("reduce"));
        this.m_bar = (this.getChild("bar"));
        this.m_hpText = (this.getChild("hpText"));
        this.m_name = (this.getChild("name"));
    }
}
exports.default = UI_HpBar;
UI_HpBar.URL = "ui://u9h77rfddhmvr";

},{}],99:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_JoyStick extends fgui.GComponent {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "JoyStick"));
    }
    onConstruct() {
        this.m_bg = (this.getChild("bg"));
        this.m_light = (this.getChild("light"));
        this.m_stickBar = (this.getChild("stickBar"));
    }
}
exports.default = UI_JoyStick;
UI_JoyStick.URL = "ui://u9h77rfdqjwp0";

},{}],100:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_PeopleItem extends fgui.GComponent {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "PeopleItem"));
    }
    onConstruct() {
        this.m_name = (this.getChild("name"));
        this.m_input1 = (this.getChild("input1"));
        this.m_input2 = (this.getChild("input2"));
        this.m_input3 = (this.getChild("input3"));
        this.m_input4 = (this.getChild("input4"));
        this.m_input5 = (this.getChild("input5"));
        this.m_input6 = (this.getChild("input6"));
        this.m_output = (this.getChild("output"));
    }
}
exports.default = UI_PeopleItem;
UI_PeopleItem.URL = "ui://u9h77rfdqbumx";

},{}],101:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_TimeProgressBar extends fgui.GProgressBar {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "TimeProgressBar"));
    }
    onConstruct() {
        this.m_n0 = (this.getChild("n0"));
        this.m_bar = (this.getChild("bar"));
    }
}
exports.default = UI_TimeProgressBar;
UI_TimeProgressBar.URL = "ui://u9h77rfdqbl5u";

},{}],102:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_pushButton extends fgui.GButton {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "pushButton"));
    }
    onConstruct() {
        this.m_button = this.getController("button");
        this.m_n0 = (this.getChild("n0"));
        this.m_n1 = (this.getChild("n1"));
        this.m_n2 = (this.getChild("n2"));
        this.m_title = (this.getChild("title"));
    }
}
exports.default = UI_pushButton;
UI_pushButton.URL = "ui://u9h77rfdqbl5w";

},{}],103:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_sliderButton extends fgui.GButton {
    static createInstance() {
        return (fgui.UIPackage.createObject("Battle", "sliderButton"));
    }
    onConstruct() {
        this.m_button = this.getController("button");
        this.m_n0 = (this.getChild("n0"));
        this.m_n1 = (this.getChild("n1"));
        this.m_n2 = (this.getChild("n2"));
        this.m_title = (this.getChild("title"));
    }
}
exports.default = UI_sliderButton;
UI_sliderButton.URL = "ui://u9h77rfdl007z";

},{}],104:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
const UI_Loading_1 = require("./UI_Loading");
const UI_ProgressBar_1 = require("./UI_ProgressBar");
class CommonBinder {
    static bindAll() {
        fgui.UIObjectFactory.setExtension(UI_Loading_1.default.URL, UI_Loading_1.default);
        fgui.UIObjectFactory.setExtension(UI_ProgressBar_1.default.URL, UI_ProgressBar_1.default);
    }
}
exports.default = CommonBinder;

},{"./UI_Loading":105,"./UI_ProgressBar":106}],105:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_Loading extends fgui.GComponent {
    static createInstance() {
        return (fgui.UIPackage.createObject("Common", "Loading"));
    }
    onConstruct() {
        this.m_bg = (this.getChild("bg"));
        this.m_progressBar = (this.getChild("progressBar"));
        this.m_n7 = (this.getChild("n7"));
    }
}
exports.default = UI_Loading;
UI_Loading.URL = "ui://iic8enjxb1se0";

},{}],106:[function(require,module,exports){
"use strict";
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
class UI_ProgressBar extends fgui.GProgressBar {
    static createInstance() {
        return (fgui.UIPackage.createObject("Common", "ProgressBar"));
    }
    onConstruct() {
        this.m_n0 = (this.getChild("n0"));
        this.m_bar = (this.getChild("bar"));
    }
}
exports.default = UI_ProgressBar;
UI_ProgressBar.URL = "ui://iic8enjxb1se1";

},{}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ui = void 0;
var Scene = Laya.Scene;
var REG = Laya.ClassUtils.regClass;
var ui;
(function (ui) {
    var test;
    (function (test) {
        class TestSceneUI extends Scene {
            constructor() { super(); }
            createChildren() {
                super.createChildren();
                this.loadScene("test/TestScene");
            }
        }
        test.TestSceneUI = TestSceneUI;
        REG("ui.test.TestSceneUI", TestSceneUI);
    })(test = ui.test || (ui.test = {}));
})(ui = exports.ui || (exports.ui = {}));

},{}]},{},[2])

//# sourceMappingURL=bundle.js.map
